package celt;

import opus.Jopus_defines;

/* Copyright ( c ) 2007 - 2008 CSIRO
Copyright ( c ) 2007 - 2009 Xiph.Org Foundation
Copyright ( c ) 2008 Gregory Maxwell
Written by Jean - Marc Valin and Gregory Maxwell */

/* The contents of this file was automatically generated by dump_modes.c
with arguments: 48000 960
It contains static definitions for some pre-defined modes. */

// celt.h

public final class JCELTMode extends JOpusCustomMode {
	// start modes.c
	private static final short eband5ms[] = {// FIXME why int16?
		/*0  200 400 600 800  1k 1.2 1.4 1.6  2k 2.4 2.8 3.2  4k 4.8 5.6 6.8  8k 9.6 12k 15.6 */
		  0,  1,  2,  3,  4,  5,  6,  7,  8, 10, 12, 14, 16, 20, 24, 28, 34, 40, 48, 60, 78, 100
	};

	/** Alternate tuning (partially derived from Vorbis) */
	// private static final int BITALLOC_SIZE = 11;
	/** Bit allocation table in units of 1/32 bit/sample (0.1875 dB SNR) */
	private static final char band_allocation[] = {// java uint8 to char
		/*0  200 400 600 800  1k 1.2 1.4 1.6  2k 2.4 2.8 3.2  4k 4.8 5.6 6.8  8k 9.6 12k 15.6 */
		  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
		 90, 80, 75, 69, 63, 56, 49, 40, 34, 29, 20, 18, 10,  0,  0,  0,  0,  0,  0,  0,  0,
		110,100, 90, 84, 78, 71, 65, 58, 51, 45, 39, 32, 26, 20, 12,  0,  0,  0,  0,  0,  0,
		118,110,103, 93, 86, 80, 75, 70, 65, 59, 53, 47, 40, 31, 23, 15,  4,  0,  0,  0,  0,
		126,119,112,104, 95, 89, 83, 78, 72, 66, 60, 54, 47, 39, 32, 25, 17, 12,  1,  0,  0,
		134,127,120,114,103, 97, 91, 85, 78, 72, 66, 60, 54, 47, 41, 35, 29, 23, 16, 10,  1,
		144,137,130,124,113,107,101, 95, 88, 82, 76, 70, 64, 57, 51, 45, 39, 33, 26, 15,  1,
		152,145,138,132,123,117,111,105, 98, 92, 86, 80, 74, 67, 61, 55, 49, 43, 36, 20,  1,
		162,155,148,142,133,127,121,115,108,102, 96, 90, 84, 77, 71, 65, 59, 53, 46, 30,  1,
		172,165,158,152,143,137,131,125,118,112,106,100, 94, 87, 81, 75, 69, 63, 56, 45, 20,
		200,200,200,200,200,200,200,200,198,193,188,183,178,173,168,163,158,153,148,129,104,
	};
	// end modes.c

	// start static_modes_float.h
// #ifndef DEF_WINDOW120
// #define DEF_WINDOW120
	private static final float window120[/* 120 */] = {
		6.7286966e-05f, 0.00060551348f, 0.0016815970f, 0.0032947962f, 0.0054439943f,
		0.0081276923f, 0.011344001f, 0.015090633f, 0.019364886f, 0.024163635f,
		0.029483315f, 0.035319905f, 0.041668911f, 0.048525347f, 0.055883718f,
		0.063737999f, 0.072081616f, 0.080907428f, 0.090207705f, 0.099974111f,
		0.11019769f, 0.12086883f, 0.13197729f, 0.14351214f, 0.15546177f,
		0.16781389f, 0.18055550f, 0.19367290f, 0.20715171f, 0.22097682f,
		0.23513243f, 0.24960208f, 0.26436860f, 0.27941419f, 0.29472040f,
		0.31026818f, 0.32603788f, 0.34200931f, 0.35816177f, 0.37447407f,
		0.39092462f, 0.40749142f, 0.42415215f, 0.44088423f, 0.45766484f,
		0.47447104f, 0.49127978f, 0.50806798f, 0.52481261f, 0.54149077f,
		0.55807973f, 0.57455701f, 0.59090049f, 0.60708841f, 0.62309951f,
		0.63891306f, 0.65450896f, 0.66986776f, 0.68497077f, 0.69980010f,
		0.71433873f, 0.72857055f, 0.74248043f, 0.75605424f, 0.76927895f,
		0.78214257f, 0.79463430f, 0.80674445f, 0.81846456f, 0.82978733f,
		0.84070669f, 0.85121779f, 0.86131698f, 0.87100183f, 0.88027111f,
		0.88912479f, 0.89756398f, 0.90559094f, 0.91320904f, 0.92042270f,
		0.92723738f, 0.93365955f, 0.93969656f, 0.94535671f, 0.95064907f,
		0.95558353f, 0.96017067f, 0.96442171f, 0.96834849f, 0.97196334f,
		0.97527906f, 0.97830883f, 0.98106616f, 0.98356480f, 0.98581869f,
		0.98784191f, 0.98964856f, 0.99125274f, 0.99266849f, 0.99390969f,
		0.99499004f, 0.99592297f, 0.99672162f, 0.99739874f, 0.99796667f,
		0.99843728f, 0.99882195f, 0.99913147f, 0.99937606f, 0.99956527f,
		0.99970802f, 0.99981248f, 0.99988613f, 0.99993565f, 0.99996697f,
		0.99998518f, 0.99999457f, 0.99999859f, 0.99999982f, 1.0000000f,
	};
// #endif

// #ifndef DEF_LOGN400
// #define DEF_LOGN400
	private static final short logN400[/* 21 */] = {
			0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 16, 16, 16, 21, 21, 24, 29, 34, 36, };
// #endif

// #ifndef DEF_PULSE_CACHE50
// #define DEF_PULSE_CACHE50
	private static final short cache_index50[/* 105 */] = {
		-1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 41, 41, 41,
		82, 82, 123, 164, 200, 222, 0, 0, 0, 0, 0, 0, 0, 0, 41,
		41, 41, 41, 123, 123, 123, 164, 164, 240, 266, 283, 295, 41, 41, 41,
		41, 41, 41, 41, 41, 123, 123, 123, 123, 240, 240, 240, 266, 266, 305,
		318, 328, 336, 123, 123, 123, 123, 123, 123, 123, 123, 240, 240, 240, 240,
		305, 305, 305, 318, 318, 343, 351, 358, 364, 240, 240, 240, 240, 240, 240,
		240, 240, 305, 305, 305, 305, 343, 343, 343, 351, 351, 370, 376, 382, 387,
	};
	private static final char cache_bits50[/* 392 */] = {// java uint8 to char
		40, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
		7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 40, 15, 23, 28,
		31, 34, 36, 38, 39, 41, 42, 43, 44, 45, 46, 47, 47, 49, 50,
		51, 52, 53, 54, 55, 55, 57, 58, 59, 60, 61, 62, 63, 63, 65,
		66, 67, 68, 69, 70, 71, 71, 40, 20, 33, 41, 48, 53, 57, 61,
		64, 66, 69, 71, 73, 75, 76, 78, 80, 82, 85, 87, 89, 91, 92,
		94, 96, 98, 101, 103, 105, 107, 108, 110, 112, 114, 117, 119, 121, 123,
		124, 126, 128, 40, 23, 39, 51, 60, 67, 73, 79, 83, 87, 91, 94,
		97, 100, 102, 105, 107, 111, 115, 118, 121, 124, 126, 129, 131, 135, 139,
		142, 145, 148, 150, 153, 155, 159, 163, 166, 169, 172, 174, 177, 179, 35,
		28, 49, 65, 78, 89, 99, 107, 114, 120, 126, 132, 136, 141, 145, 149,
		153, 159, 165, 171, 176, 180, 185, 189, 192, 199, 205, 211, 216, 220, 225,
		229, 232, 239, 245, 251, 21, 33, 58, 79, 97, 112, 125, 137, 148, 157,
		166, 174, 182, 189, 195, 201, 207, 217, 227, 235, 243, 251, 17, 35, 63,
		86, 106, 123, 139, 152, 165, 177, 187, 197, 206, 214, 222, 230, 237, 250,
		25, 31, 55, 75, 91, 105, 117, 128, 138, 146, 154, 161, 168, 174, 180,
		185, 190, 200, 208, 215, 222, 229, 235, 240, 245, 255, 16, 36, 65, 89,
		110, 128, 144, 159, 173, 185, 196, 207, 217, 226, 234, 242, 250, 11, 41,
		74, 103, 128, 151, 172, 191, 209, 225, 241, 255, 9, 43, 79, 110, 138,
		163, 186, 207, 227, 246, 12, 39, 71, 99, 123, 144, 164, 182, 198, 214,
		228, 241, 253, 9, 44, 81, 113, 142, 168, 192, 214, 235, 255, 7, 49,
		90, 127, 160, 191, 220, 247, 6, 51, 95, 134, 170, 203, 234, 7, 47,
		87, 123, 155, 184, 212, 237, 6, 52, 97, 137, 174, 208, 240, 5, 57,
		106, 151, 192, 231, 5, 59, 111, 158, 202, 243, 5, 55, 103, 147, 187,
		224, 5, 60, 113, 161, 206, 248, 4, 65, 122, 175, 224, 4, 67, 127,
		182, 234, };

	private static final char cache_caps50[/* 168 */] = {// java uint8 to char
		224, 224, 224, 224, 224, 224, 224, 224, 160, 160, 160, 160, 185, 185, 185,
		178, 178, 168, 134, 61, 37, 224, 224, 224, 224, 224, 224, 224, 224, 240,
		240, 240, 240, 207, 207, 207, 198, 198, 183, 144, 66, 40, 160, 160, 160,
		160, 160, 160, 160, 160, 185, 185, 185, 185, 193, 193, 193, 183, 183, 172,
		138, 64, 38, 240, 240, 240, 240, 240, 240, 240, 240, 207, 207, 207, 207,
		204, 204, 204, 193, 193, 180, 143, 66, 40, 185, 185, 185, 185, 185, 185,
		185, 185, 193, 193, 193, 193, 193, 193, 193, 183, 183, 172, 138, 65, 39,
		207, 207, 207, 207, 207, 207, 207, 207, 204, 204, 204, 204, 201, 201, 201,
		188, 188, 176, 141, 66, 40, 193, 193, 193, 193, 193, 193, 193, 193, 193,
		193, 193, 193, 194, 194, 194, 184, 184, 173, 139, 65, 39, 204, 204, 204,
		204, 204, 204, 204, 204, 201, 201, 201, 201, 198, 198, 198, 187, 187, 175,
		140, 66, 40, };
// #endif

// #ifndef FFT_TWIDDLES48000_960
// #define FFT_TWIDDLES48000_960
	private static final Jkiss_twiddle_cpx fft_twiddles48000_960[/* 480 */] = {
		new Jkiss_twiddle_cpx( 1.0000000f, -0.0000000f ), new Jkiss_twiddle_cpx( 0.99991433f, -0.013089596f ),
		new Jkiss_twiddle_cpx( 0.99965732f, -0.026176948f ), new Jkiss_twiddle_cpx( 0.99922904f, -0.039259816f ),
		new Jkiss_twiddle_cpx( 0.99862953f, -0.052335956f ), new Jkiss_twiddle_cpx( 0.99785892f, -0.065403129f ),
		new Jkiss_twiddle_cpx( 0.99691733f, -0.078459096f ), new Jkiss_twiddle_cpx( 0.99580493f, -0.091501619f ),
		new Jkiss_twiddle_cpx( 0.99452190f, -0.10452846f ), new Jkiss_twiddle_cpx( 0.99306846f, -0.11753740f ),
		new Jkiss_twiddle_cpx( 0.99144486f, -0.13052619f ), new Jkiss_twiddle_cpx( 0.98965139f, -0.14349262f ),
		new Jkiss_twiddle_cpx( 0.98768834f, -0.15643447f ), new Jkiss_twiddle_cpx( 0.98555606f, -0.16934950f ),
		new Jkiss_twiddle_cpx( 0.98325491f, -0.18223553f ), new Jkiss_twiddle_cpx( 0.98078528f, -0.19509032f ),
		new Jkiss_twiddle_cpx( 0.97814760f, -0.20791169f ), new Jkiss_twiddle_cpx( 0.97534232f, -0.22069744f ),
		new Jkiss_twiddle_cpx( 0.97236992f, -0.23344536f ), new Jkiss_twiddle_cpx( 0.96923091f, -0.24615329f ),
		new Jkiss_twiddle_cpx( 0.96592583f, -0.25881905f ), new Jkiss_twiddle_cpx( 0.96245524f, -0.27144045f ),
		new Jkiss_twiddle_cpx( 0.95881973f, -0.28401534f ), new Jkiss_twiddle_cpx( 0.95501994f, -0.29654157f ),
		new Jkiss_twiddle_cpx( 0.95105652f, -0.30901699f ), new Jkiss_twiddle_cpx( 0.94693013f, -0.32143947f ),
		new Jkiss_twiddle_cpx( 0.94264149f, -0.33380686f ), new Jkiss_twiddle_cpx( 0.93819134f, -0.34611706f ),
		new Jkiss_twiddle_cpx( 0.93358043f, -0.35836795f ), new Jkiss_twiddle_cpx( 0.92880955f, -0.37055744f ),
		new Jkiss_twiddle_cpx( 0.92387953f, -0.38268343f ), new Jkiss_twiddle_cpx( 0.91879121f, -0.39474386f ),
		new Jkiss_twiddle_cpx( 0.91354546f, -0.40673664f ), new Jkiss_twiddle_cpx( 0.90814317f, -0.41865974f ),
		new Jkiss_twiddle_cpx( 0.90258528f, -0.43051110f ), new Jkiss_twiddle_cpx( 0.89687274f, -0.44228869f ),
		new Jkiss_twiddle_cpx( 0.89100652f, -0.45399050f ), new Jkiss_twiddle_cpx( 0.88498764f, -0.46561452f ),
		new Jkiss_twiddle_cpx( 0.87881711f, -0.47715876f ), new Jkiss_twiddle_cpx( 0.87249601f, -0.48862124f ),
		new Jkiss_twiddle_cpx( 0.86602540f, -0.50000000f ), new Jkiss_twiddle_cpx( 0.85940641f, -0.51129309f ),
		new Jkiss_twiddle_cpx( 0.85264016f, -0.52249856f ), new Jkiss_twiddle_cpx( 0.84572782f, -0.53361452f ),
		new Jkiss_twiddle_cpx( 0.83867057f, -0.54463904f ), new Jkiss_twiddle_cpx( 0.83146961f, -0.55557023f ),
		new Jkiss_twiddle_cpx( 0.82412619f, -0.56640624f ), new Jkiss_twiddle_cpx( 0.81664156f, -0.57714519f ),
		new Jkiss_twiddle_cpx( 0.80901699f, -0.58778525f ), new Jkiss_twiddle_cpx( 0.80125381f, -0.59832460f ),
		new Jkiss_twiddle_cpx( 0.79335334f, -0.60876143f ), new Jkiss_twiddle_cpx( 0.78531693f, -0.61909395f ),
		new Jkiss_twiddle_cpx( 0.77714596f, -0.62932039f ), new Jkiss_twiddle_cpx( 0.76884183f, -0.63943900f ),
		new Jkiss_twiddle_cpx( 0.76040597f, -0.64944805f ), new Jkiss_twiddle_cpx( 0.75183981f, -0.65934582f ),
		new Jkiss_twiddle_cpx( 0.74314483f, -0.66913061f ), new Jkiss_twiddle_cpx( 0.73432251f, -0.67880075f ),
		new Jkiss_twiddle_cpx( 0.72537437f, -0.68835458f ), new Jkiss_twiddle_cpx( 0.71630194f, -0.69779046f ),
		new Jkiss_twiddle_cpx( 0.70710678f, -0.70710678f ), new Jkiss_twiddle_cpx( 0.69779046f, -0.71630194f ),
		new Jkiss_twiddle_cpx( 0.68835458f, -0.72537437f ), new Jkiss_twiddle_cpx( 0.67880075f, -0.73432251f ),
		new Jkiss_twiddle_cpx( 0.66913061f, -0.74314483f ), new Jkiss_twiddle_cpx( 0.65934582f, -0.75183981f ),
		new Jkiss_twiddle_cpx( 0.64944805f, -0.76040597f ), new Jkiss_twiddle_cpx( 0.63943900f, -0.76884183f ),
		new Jkiss_twiddle_cpx( 0.62932039f, -0.77714596f ), new Jkiss_twiddle_cpx( 0.61909395f, -0.78531693f ),
		new Jkiss_twiddle_cpx( 0.60876143f, -0.79335334f ), new Jkiss_twiddle_cpx( 0.59832460f, -0.80125381f ),
		new Jkiss_twiddle_cpx( 0.58778525f, -0.80901699f ), new Jkiss_twiddle_cpx( 0.57714519f, -0.81664156f ),
		new Jkiss_twiddle_cpx( 0.56640624f, -0.82412619f ), new Jkiss_twiddle_cpx( 0.55557023f, -0.83146961f ),
		new Jkiss_twiddle_cpx( 0.54463904f, -0.83867057f ), new Jkiss_twiddle_cpx( 0.53361452f, -0.84572782f ),
		new Jkiss_twiddle_cpx( 0.52249856f, -0.85264016f ), new Jkiss_twiddle_cpx( 0.51129309f, -0.85940641f ),
		new Jkiss_twiddle_cpx( 0.50000000f, -0.86602540f ), new Jkiss_twiddle_cpx( 0.48862124f, -0.87249601f ),
		new Jkiss_twiddle_cpx( 0.47715876f, -0.87881711f ), new Jkiss_twiddle_cpx( 0.46561452f, -0.88498764f ),
		new Jkiss_twiddle_cpx( 0.45399050f, -0.89100652f ), new Jkiss_twiddle_cpx( 0.44228869f, -0.89687274f ),
		new Jkiss_twiddle_cpx( 0.43051110f, -0.90258528f ), new Jkiss_twiddle_cpx( 0.41865974f, -0.90814317f ),
		new Jkiss_twiddle_cpx( 0.40673664f, -0.91354546f ), new Jkiss_twiddle_cpx( 0.39474386f, -0.91879121f ),
		new Jkiss_twiddle_cpx( 0.38268343f, -0.92387953f ), new Jkiss_twiddle_cpx( 0.37055744f, -0.92880955f ),
		new Jkiss_twiddle_cpx( 0.35836795f, -0.93358043f ), new Jkiss_twiddle_cpx( 0.34611706f, -0.93819134f ),
		new Jkiss_twiddle_cpx( 0.33380686f, -0.94264149f ), new Jkiss_twiddle_cpx( 0.32143947f, -0.94693013f ),
		new Jkiss_twiddle_cpx( 0.30901699f, -0.95105652f ), new Jkiss_twiddle_cpx( 0.29654157f, -0.95501994f ),
		new Jkiss_twiddle_cpx( 0.28401534f, -0.95881973f ), new Jkiss_twiddle_cpx( 0.27144045f, -0.96245524f ),
		new Jkiss_twiddle_cpx( 0.25881905f, -0.96592583f ), new Jkiss_twiddle_cpx( 0.24615329f, -0.96923091f ),
		new Jkiss_twiddle_cpx( 0.23344536f, -0.97236992f ), new Jkiss_twiddle_cpx( 0.22069744f, -0.97534232f ),
		new Jkiss_twiddle_cpx( 0.20791169f, -0.97814760f ), new Jkiss_twiddle_cpx( 0.19509032f, -0.98078528f ),
		new Jkiss_twiddle_cpx( 0.18223553f, -0.98325491f ), new Jkiss_twiddle_cpx( 0.16934950f, -0.98555606f ),
		new Jkiss_twiddle_cpx( 0.15643447f, -0.98768834f ), new Jkiss_twiddle_cpx( 0.14349262f, -0.98965139f ),
		new Jkiss_twiddle_cpx( 0.13052619f, -0.99144486f ), new Jkiss_twiddle_cpx( 0.11753740f, -0.99306846f ),
		new Jkiss_twiddle_cpx( 0.10452846f, -0.99452190f ), new Jkiss_twiddle_cpx( 0.091501619f, -0.99580493f ),
		new Jkiss_twiddle_cpx( 0.078459096f, -0.99691733f ), new Jkiss_twiddle_cpx( 0.065403129f, -0.99785892f ),
		new Jkiss_twiddle_cpx( 0.052335956f, -0.99862953f ), new Jkiss_twiddle_cpx( 0.039259816f, -0.99922904f ),
		new Jkiss_twiddle_cpx( 0.026176948f, -0.99965732f ), new Jkiss_twiddle_cpx( 0.013089596f, -0.99991433f ),
		new Jkiss_twiddle_cpx( 6.1230318e-17f, -1.0000000f ), new Jkiss_twiddle_cpx( -0.013089596f, -0.99991433f ),
		new Jkiss_twiddle_cpx( -0.026176948f, -0.99965732f ), new Jkiss_twiddle_cpx( -0.039259816f, -0.99922904f ),
		new Jkiss_twiddle_cpx( -0.052335956f, -0.99862953f ), new Jkiss_twiddle_cpx( -0.065403129f, -0.99785892f ),
		new Jkiss_twiddle_cpx( -0.078459096f, -0.99691733f ), new Jkiss_twiddle_cpx( -0.091501619f, -0.99580493f ),
		new Jkiss_twiddle_cpx( -0.10452846f, -0.99452190f ), new Jkiss_twiddle_cpx( -0.11753740f, -0.99306846f ),
		new Jkiss_twiddle_cpx( -0.13052619f, -0.99144486f ), new Jkiss_twiddle_cpx( -0.14349262f, -0.98965139f ),
		new Jkiss_twiddle_cpx( -0.15643447f, -0.98768834f ), new Jkiss_twiddle_cpx( -0.16934950f, -0.98555606f ),
		new Jkiss_twiddle_cpx( -0.18223553f, -0.98325491f ), new Jkiss_twiddle_cpx( -0.19509032f, -0.98078528f ),
		new Jkiss_twiddle_cpx( -0.20791169f, -0.97814760f ), new Jkiss_twiddle_cpx( -0.22069744f, -0.97534232f ),
		new Jkiss_twiddle_cpx( -0.23344536f, -0.97236992f ), new Jkiss_twiddle_cpx( -0.24615329f, -0.96923091f ),
		new Jkiss_twiddle_cpx( -0.25881905f, -0.96592583f ), new Jkiss_twiddle_cpx( -0.27144045f, -0.96245524f ),
		new Jkiss_twiddle_cpx( -0.28401534f, -0.95881973f ), new Jkiss_twiddle_cpx( -0.29654157f, -0.95501994f ),
		new Jkiss_twiddle_cpx( -0.30901699f, -0.95105652f ), new Jkiss_twiddle_cpx( -0.32143947f, -0.94693013f ),
		new Jkiss_twiddle_cpx( -0.33380686f, -0.94264149f ), new Jkiss_twiddle_cpx( -0.34611706f, -0.93819134f ),
		new Jkiss_twiddle_cpx( -0.35836795f, -0.93358043f ), new Jkiss_twiddle_cpx( -0.37055744f, -0.92880955f ),
		new Jkiss_twiddle_cpx( -0.38268343f, -0.92387953f ), new Jkiss_twiddle_cpx( -0.39474386f, -0.91879121f ),
		new Jkiss_twiddle_cpx( -0.40673664f, -0.91354546f ), new Jkiss_twiddle_cpx( -0.41865974f, -0.90814317f ),
		new Jkiss_twiddle_cpx( -0.43051110f, -0.90258528f ), new Jkiss_twiddle_cpx( -0.44228869f, -0.89687274f ),
		new Jkiss_twiddle_cpx( -0.45399050f, -0.89100652f ), new Jkiss_twiddle_cpx( -0.46561452f, -0.88498764f ),
		new Jkiss_twiddle_cpx( -0.47715876f, -0.87881711f ), new Jkiss_twiddle_cpx( -0.48862124f, -0.87249601f ),
		new Jkiss_twiddle_cpx( -0.50000000f, -0.86602540f ), new Jkiss_twiddle_cpx( -0.51129309f, -0.85940641f ),
		new Jkiss_twiddle_cpx( -0.52249856f, -0.85264016f ), new Jkiss_twiddle_cpx( -0.53361452f, -0.84572782f ),
		new Jkiss_twiddle_cpx( -0.54463904f, -0.83867057f ), new Jkiss_twiddle_cpx( -0.55557023f, -0.83146961f ),
		new Jkiss_twiddle_cpx( -0.56640624f, -0.82412619f ), new Jkiss_twiddle_cpx( -0.57714519f, -0.81664156f ),
		new Jkiss_twiddle_cpx( -0.58778525f, -0.80901699f ), new Jkiss_twiddle_cpx( -0.59832460f, -0.80125381f ),
		new Jkiss_twiddle_cpx( -0.60876143f, -0.79335334f ), new Jkiss_twiddle_cpx( -0.61909395f, -0.78531693f ),
		new Jkiss_twiddle_cpx( -0.62932039f, -0.77714596f ), new Jkiss_twiddle_cpx( -0.63943900f, -0.76884183f ),
		new Jkiss_twiddle_cpx( -0.64944805f, -0.76040597f ), new Jkiss_twiddle_cpx( -0.65934582f, -0.75183981f ),
		new Jkiss_twiddle_cpx( -0.66913061f, -0.74314483f ), new Jkiss_twiddle_cpx( -0.67880075f, -0.73432251f ),
		new Jkiss_twiddle_cpx( -0.68835458f, -0.72537437f ), new Jkiss_twiddle_cpx( -0.69779046f, -0.71630194f ),
		new Jkiss_twiddle_cpx( -0.70710678f, -0.70710678f ), new Jkiss_twiddle_cpx( -0.71630194f, -0.69779046f ),
		new Jkiss_twiddle_cpx( -0.72537437f, -0.68835458f ), new Jkiss_twiddle_cpx( -0.73432251f, -0.67880075f ),
		new Jkiss_twiddle_cpx( -0.74314483f, -0.66913061f ), new Jkiss_twiddle_cpx( -0.75183981f, -0.65934582f ),
		new Jkiss_twiddle_cpx( -0.76040597f, -0.64944805f ), new Jkiss_twiddle_cpx( -0.76884183f, -0.63943900f ),
		new Jkiss_twiddle_cpx( -0.77714596f, -0.62932039f ), new Jkiss_twiddle_cpx( -0.78531693f, -0.61909395f ),
		new Jkiss_twiddle_cpx( -0.79335334f, -0.60876143f ), new Jkiss_twiddle_cpx( -0.80125381f, -0.59832460f ),
		new Jkiss_twiddle_cpx( -0.80901699f, -0.58778525f ), new Jkiss_twiddle_cpx( -0.81664156f, -0.57714519f ),
		new Jkiss_twiddle_cpx( -0.82412619f, -0.56640624f ), new Jkiss_twiddle_cpx( -0.83146961f, -0.55557023f ),
		new Jkiss_twiddle_cpx( -0.83867057f, -0.54463904f ), new Jkiss_twiddle_cpx( -0.84572782f, -0.53361452f ),
		new Jkiss_twiddle_cpx( -0.85264016f, -0.52249856f ), new Jkiss_twiddle_cpx( -0.85940641f, -0.51129309f ),
		new Jkiss_twiddle_cpx( -0.86602540f, -0.50000000f ), new Jkiss_twiddle_cpx( -0.87249601f, -0.48862124f ),
		new Jkiss_twiddle_cpx( -0.87881711f, -0.47715876f ), new Jkiss_twiddle_cpx( -0.88498764f, -0.46561452f ),
		new Jkiss_twiddle_cpx( -0.89100652f, -0.45399050f ), new Jkiss_twiddle_cpx( -0.89687274f, -0.44228869f ),
		new Jkiss_twiddle_cpx( -0.90258528f, -0.43051110f ), new Jkiss_twiddle_cpx( -0.90814317f, -0.41865974f ),
		new Jkiss_twiddle_cpx( -0.91354546f, -0.40673664f ), new Jkiss_twiddle_cpx( -0.91879121f, -0.39474386f ),
		new Jkiss_twiddle_cpx( -0.92387953f, -0.38268343f ), new Jkiss_twiddle_cpx( -0.92880955f, -0.37055744f ),
		new Jkiss_twiddle_cpx( -0.93358043f, -0.35836795f ), new Jkiss_twiddle_cpx( -0.93819134f, -0.34611706f ),
		new Jkiss_twiddle_cpx( -0.94264149f, -0.33380686f ), new Jkiss_twiddle_cpx( -0.94693013f, -0.32143947f ),
		new Jkiss_twiddle_cpx( -0.95105652f, -0.30901699f ), new Jkiss_twiddle_cpx( -0.95501994f, -0.29654157f ),
		new Jkiss_twiddle_cpx( -0.95881973f, -0.28401534f ), new Jkiss_twiddle_cpx( -0.96245524f, -0.27144045f ),
		new Jkiss_twiddle_cpx( -0.96592583f, -0.25881905f ), new Jkiss_twiddle_cpx( -0.96923091f, -0.24615329f ),
		new Jkiss_twiddle_cpx( -0.97236992f, -0.23344536f ), new Jkiss_twiddle_cpx( -0.97534232f, -0.22069744f ),
		new Jkiss_twiddle_cpx( -0.97814760f, -0.20791169f ), new Jkiss_twiddle_cpx( -0.98078528f, -0.19509032f ),
		new Jkiss_twiddle_cpx( -0.98325491f, -0.18223553f ), new Jkiss_twiddle_cpx( -0.98555606f, -0.16934950f ),
		new Jkiss_twiddle_cpx( -0.98768834f, -0.15643447f ), new Jkiss_twiddle_cpx( -0.98965139f, -0.14349262f ),
		new Jkiss_twiddle_cpx( -0.99144486f, -0.13052619f ), new Jkiss_twiddle_cpx( -0.99306846f, -0.11753740f ),
		new Jkiss_twiddle_cpx( -0.99452190f, -0.10452846f ), new Jkiss_twiddle_cpx( -0.99580493f, -0.091501619f ),
		new Jkiss_twiddle_cpx( -0.99691733f, -0.078459096f ), new Jkiss_twiddle_cpx( -0.99785892f, -0.065403129f ),
		new Jkiss_twiddle_cpx( -0.99862953f, -0.052335956f ), new Jkiss_twiddle_cpx( -0.99922904f, -0.039259816f ),
		new Jkiss_twiddle_cpx( -0.99965732f, -0.026176948f ), new Jkiss_twiddle_cpx( -0.99991433f, -0.013089596f ),
		new Jkiss_twiddle_cpx( -1.0000000f, -1.2246064e-16f ), new Jkiss_twiddle_cpx( -0.99991433f, 0.013089596f ),
		new Jkiss_twiddle_cpx( -0.99965732f, 0.026176948f ), new Jkiss_twiddle_cpx( -0.99922904f, 0.039259816f ),
		new Jkiss_twiddle_cpx( -0.99862953f, 0.052335956f ), new Jkiss_twiddle_cpx( -0.99785892f, 0.065403129f ),
		new Jkiss_twiddle_cpx( -0.99691733f, 0.078459096f ), new Jkiss_twiddle_cpx( -0.99580493f, 0.091501619f ),
		new Jkiss_twiddle_cpx( -0.99452190f, 0.10452846f ), new Jkiss_twiddle_cpx( -0.99306846f, 0.11753740f ),
		new Jkiss_twiddle_cpx( -0.99144486f, 0.13052619f ), new Jkiss_twiddle_cpx( -0.98965139f, 0.14349262f ),
		new Jkiss_twiddle_cpx( -0.98768834f, 0.15643447f ), new Jkiss_twiddle_cpx( -0.98555606f, 0.16934950f ),
		new Jkiss_twiddle_cpx( -0.98325491f, 0.18223553f ), new Jkiss_twiddle_cpx( -0.98078528f, 0.19509032f ),
		new Jkiss_twiddle_cpx( -0.97814760f, 0.20791169f ), new Jkiss_twiddle_cpx( -0.97534232f, 0.22069744f ),
		new Jkiss_twiddle_cpx( -0.97236992f, 0.23344536f ), new Jkiss_twiddle_cpx( -0.96923091f, 0.24615329f ),
		new Jkiss_twiddle_cpx( -0.96592583f, 0.25881905f ), new Jkiss_twiddle_cpx( -0.96245524f, 0.27144045f ),
		new Jkiss_twiddle_cpx( -0.95881973f, 0.28401534f ), new Jkiss_twiddle_cpx( -0.95501994f, 0.29654157f ),
		new Jkiss_twiddle_cpx( -0.95105652f, 0.30901699f ), new Jkiss_twiddle_cpx( -0.94693013f, 0.32143947f ),
		new Jkiss_twiddle_cpx( -0.94264149f, 0.33380686f ), new Jkiss_twiddle_cpx( -0.93819134f, 0.34611706f ),
		new Jkiss_twiddle_cpx( -0.93358043f, 0.35836795f ), new Jkiss_twiddle_cpx( -0.92880955f, 0.37055744f ),
		new Jkiss_twiddle_cpx( -0.92387953f, 0.38268343f ), new Jkiss_twiddle_cpx( -0.91879121f, 0.39474386f ),
		new Jkiss_twiddle_cpx( -0.91354546f, 0.40673664f ), new Jkiss_twiddle_cpx( -0.90814317f, 0.41865974f ),
		new Jkiss_twiddle_cpx( -0.90258528f, 0.43051110f ), new Jkiss_twiddle_cpx( -0.89687274f, 0.44228869f ),
		new Jkiss_twiddle_cpx( -0.89100652f, 0.45399050f ), new Jkiss_twiddle_cpx( -0.88498764f, 0.46561452f ),
		new Jkiss_twiddle_cpx( -0.87881711f, 0.47715876f ), new Jkiss_twiddle_cpx( -0.87249601f, 0.48862124f ),
		new Jkiss_twiddle_cpx( -0.86602540f, 0.50000000f ), new Jkiss_twiddle_cpx( -0.85940641f, 0.51129309f ),
		new Jkiss_twiddle_cpx( -0.85264016f, 0.52249856f ), new Jkiss_twiddle_cpx( -0.84572782f, 0.53361452f ),
		new Jkiss_twiddle_cpx( -0.83867057f, 0.54463904f ), new Jkiss_twiddle_cpx( -0.83146961f, 0.55557023f ),
		new Jkiss_twiddle_cpx( -0.82412619f, 0.56640624f ), new Jkiss_twiddle_cpx( -0.81664156f, 0.57714519f ),
		new Jkiss_twiddle_cpx( -0.80901699f, 0.58778525f ), new Jkiss_twiddle_cpx( -0.80125381f, 0.59832460f ),
		new Jkiss_twiddle_cpx( -0.79335334f, 0.60876143f ), new Jkiss_twiddle_cpx( -0.78531693f, 0.61909395f ),
		new Jkiss_twiddle_cpx( -0.77714596f, 0.62932039f ), new Jkiss_twiddle_cpx( -0.76884183f, 0.63943900f ),
		new Jkiss_twiddle_cpx( -0.76040597f, 0.64944805f ), new Jkiss_twiddle_cpx( -0.75183981f, 0.65934582f ),
		new Jkiss_twiddle_cpx( -0.74314483f, 0.66913061f ), new Jkiss_twiddle_cpx( -0.73432251f, 0.67880075f ),
		new Jkiss_twiddle_cpx( -0.72537437f, 0.68835458f ), new Jkiss_twiddle_cpx( -0.71630194f, 0.69779046f ),
		new Jkiss_twiddle_cpx( -0.70710678f, 0.70710678f ), new Jkiss_twiddle_cpx( -0.69779046f, 0.71630194f ),
		new Jkiss_twiddle_cpx( -0.68835458f, 0.72537437f ), new Jkiss_twiddle_cpx( -0.67880075f, 0.73432251f ),
		new Jkiss_twiddle_cpx( -0.66913061f, 0.74314483f ), new Jkiss_twiddle_cpx( -0.65934582f, 0.75183981f ),
		new Jkiss_twiddle_cpx( -0.64944805f, 0.76040597f ), new Jkiss_twiddle_cpx( -0.63943900f, 0.76884183f ),
		new Jkiss_twiddle_cpx( -0.62932039f, 0.77714596f ), new Jkiss_twiddle_cpx( -0.61909395f, 0.78531693f ),
		new Jkiss_twiddle_cpx( -0.60876143f, 0.79335334f ), new Jkiss_twiddle_cpx( -0.59832460f, 0.80125381f ),
		new Jkiss_twiddle_cpx( -0.58778525f, 0.80901699f ), new Jkiss_twiddle_cpx( -0.57714519f, 0.81664156f ),
		new Jkiss_twiddle_cpx( -0.56640624f, 0.82412619f ), new Jkiss_twiddle_cpx( -0.55557023f, 0.83146961f ),
		new Jkiss_twiddle_cpx( -0.54463904f, 0.83867057f ), new Jkiss_twiddle_cpx( -0.53361452f, 0.84572782f ),
		new Jkiss_twiddle_cpx( -0.52249856f, 0.85264016f ), new Jkiss_twiddle_cpx( -0.51129309f, 0.85940641f ),
		new Jkiss_twiddle_cpx( -0.50000000f, 0.86602540f ), new Jkiss_twiddle_cpx( -0.48862124f, 0.87249601f ),
		new Jkiss_twiddle_cpx( -0.47715876f, 0.87881711f ), new Jkiss_twiddle_cpx( -0.46561452f, 0.88498764f ),
		new Jkiss_twiddle_cpx( -0.45399050f, 0.89100652f ), new Jkiss_twiddle_cpx( -0.44228869f, 0.89687274f ),
		new Jkiss_twiddle_cpx( -0.43051110f, 0.90258528f ), new Jkiss_twiddle_cpx( -0.41865974f, 0.90814317f ),
		new Jkiss_twiddle_cpx( -0.40673664f, 0.91354546f ), new Jkiss_twiddle_cpx( -0.39474386f, 0.91879121f ),
		new Jkiss_twiddle_cpx( -0.38268343f, 0.92387953f ), new Jkiss_twiddle_cpx( -0.37055744f, 0.92880955f ),
		new Jkiss_twiddle_cpx( -0.35836795f, 0.93358043f ), new Jkiss_twiddle_cpx( -0.34611706f, 0.93819134f ),
		new Jkiss_twiddle_cpx( -0.33380686f, 0.94264149f ), new Jkiss_twiddle_cpx( -0.32143947f, 0.94693013f ),
		new Jkiss_twiddle_cpx( -0.30901699f, 0.95105652f ), new Jkiss_twiddle_cpx( -0.29654157f, 0.95501994f ),
		new Jkiss_twiddle_cpx( -0.28401534f, 0.95881973f ), new Jkiss_twiddle_cpx( -0.27144045f, 0.96245524f ),
		new Jkiss_twiddle_cpx( -0.25881905f, 0.96592583f ), new Jkiss_twiddle_cpx( -0.24615329f, 0.96923091f ),
		new Jkiss_twiddle_cpx( -0.23344536f, 0.97236992f ), new Jkiss_twiddle_cpx( -0.22069744f, 0.97534232f ),
		new Jkiss_twiddle_cpx( -0.20791169f, 0.97814760f ), new Jkiss_twiddle_cpx( -0.19509032f, 0.98078528f ),
		new Jkiss_twiddle_cpx( -0.18223553f, 0.98325491f ), new Jkiss_twiddle_cpx( -0.16934950f, 0.98555606f ),
		new Jkiss_twiddle_cpx( -0.15643447f, 0.98768834f ), new Jkiss_twiddle_cpx( -0.14349262f, 0.98965139f ),
		new Jkiss_twiddle_cpx( -0.13052619f, 0.99144486f ), new Jkiss_twiddle_cpx( -0.11753740f, 0.99306846f ),
		new Jkiss_twiddle_cpx( -0.10452846f, 0.99452190f ), new Jkiss_twiddle_cpx( -0.091501619f, 0.99580493f ),
		new Jkiss_twiddle_cpx( -0.078459096f, 0.99691733f ), new Jkiss_twiddle_cpx( -0.065403129f, 0.99785892f ),
		new Jkiss_twiddle_cpx( -0.052335956f, 0.99862953f ), new Jkiss_twiddle_cpx( -0.039259816f, 0.99922904f ),
		new Jkiss_twiddle_cpx( -0.026176948f, 0.99965732f ), new Jkiss_twiddle_cpx( -0.013089596f, 0.99991433f ),
		new Jkiss_twiddle_cpx( -1.8369095e-16f, 1.0000000f ), new Jkiss_twiddle_cpx( 0.013089596f, 0.99991433f ),
		new Jkiss_twiddle_cpx( 0.026176948f, 0.99965732f ), new Jkiss_twiddle_cpx( 0.039259816f, 0.99922904f ),
		new Jkiss_twiddle_cpx( 0.052335956f, 0.99862953f ), new Jkiss_twiddle_cpx( 0.065403129f, 0.99785892f ),
		new Jkiss_twiddle_cpx( 0.078459096f, 0.99691733f ), new Jkiss_twiddle_cpx( 0.091501619f, 0.99580493f ),
		new Jkiss_twiddle_cpx( 0.10452846f, 0.99452190f ), new Jkiss_twiddle_cpx( 0.11753740f, 0.99306846f ),
		new Jkiss_twiddle_cpx( 0.13052619f, 0.99144486f ), new Jkiss_twiddle_cpx( 0.14349262f, 0.98965139f ),
		new Jkiss_twiddle_cpx( 0.15643447f, 0.98768834f ), new Jkiss_twiddle_cpx( 0.16934950f, 0.98555606f ),
		new Jkiss_twiddle_cpx( 0.18223553f, 0.98325491f ), new Jkiss_twiddle_cpx( 0.19509032f, 0.98078528f ),
		new Jkiss_twiddle_cpx( 0.20791169f, 0.97814760f ), new Jkiss_twiddle_cpx( 0.22069744f, 0.97534232f ),
		new Jkiss_twiddle_cpx( 0.23344536f, 0.97236992f ), new Jkiss_twiddle_cpx( 0.24615329f, 0.96923091f ),
		new Jkiss_twiddle_cpx( 0.25881905f, 0.96592583f ), new Jkiss_twiddle_cpx( 0.27144045f, 0.96245524f ),
		new Jkiss_twiddle_cpx( 0.28401534f, 0.95881973f ), new Jkiss_twiddle_cpx( 0.29654157f, 0.95501994f ),
		new Jkiss_twiddle_cpx( 0.30901699f, 0.95105652f ), new Jkiss_twiddle_cpx( 0.32143947f, 0.94693013f ),
		new Jkiss_twiddle_cpx( 0.33380686f, 0.94264149f ), new Jkiss_twiddle_cpx( 0.34611706f, 0.93819134f ),
		new Jkiss_twiddle_cpx( 0.35836795f, 0.93358043f ), new Jkiss_twiddle_cpx( 0.37055744f, 0.92880955f ),
		new Jkiss_twiddle_cpx( 0.38268343f, 0.92387953f ), new Jkiss_twiddle_cpx( 0.39474386f, 0.91879121f ),
		new Jkiss_twiddle_cpx( 0.40673664f, 0.91354546f ), new Jkiss_twiddle_cpx( 0.41865974f, 0.90814317f ),
		new Jkiss_twiddle_cpx( 0.43051110f, 0.90258528f ), new Jkiss_twiddle_cpx( 0.44228869f, 0.89687274f ),
		new Jkiss_twiddle_cpx( 0.45399050f, 0.89100652f ), new Jkiss_twiddle_cpx( 0.46561452f, 0.88498764f ),
		new Jkiss_twiddle_cpx( 0.47715876f, 0.87881711f ), new Jkiss_twiddle_cpx( 0.48862124f, 0.87249601f ),
		new Jkiss_twiddle_cpx( 0.50000000f, 0.86602540f ), new Jkiss_twiddle_cpx( 0.51129309f, 0.85940641f ),
		new Jkiss_twiddle_cpx( 0.52249856f, 0.85264016f ), new Jkiss_twiddle_cpx( 0.53361452f, 0.84572782f ),
		new Jkiss_twiddle_cpx( 0.54463904f, 0.83867057f ), new Jkiss_twiddle_cpx( 0.55557023f, 0.83146961f ),
		new Jkiss_twiddle_cpx( 0.56640624f, 0.82412619f ), new Jkiss_twiddle_cpx( 0.57714519f, 0.81664156f ),
		new Jkiss_twiddle_cpx( 0.58778525f, 0.80901699f ), new Jkiss_twiddle_cpx( 0.59832460f, 0.80125381f ),
		new Jkiss_twiddle_cpx( 0.60876143f, 0.79335334f ), new Jkiss_twiddle_cpx( 0.61909395f, 0.78531693f ),
		new Jkiss_twiddle_cpx( 0.62932039f, 0.77714596f ), new Jkiss_twiddle_cpx( 0.63943900f, 0.76884183f ),
		new Jkiss_twiddle_cpx( 0.64944805f, 0.76040597f ), new Jkiss_twiddle_cpx( 0.65934582f, 0.75183981f ),
		new Jkiss_twiddle_cpx( 0.66913061f, 0.74314483f ), new Jkiss_twiddle_cpx( 0.67880075f, 0.73432251f ),
		new Jkiss_twiddle_cpx( 0.68835458f, 0.72537437f ), new Jkiss_twiddle_cpx( 0.69779046f, 0.71630194f ),
		new Jkiss_twiddle_cpx( 0.70710678f, 0.70710678f ), new Jkiss_twiddle_cpx( 0.71630194f, 0.69779046f ),
		new Jkiss_twiddle_cpx( 0.72537437f, 0.68835458f ), new Jkiss_twiddle_cpx( 0.73432251f, 0.67880075f ),
		new Jkiss_twiddle_cpx( 0.74314483f, 0.66913061f ), new Jkiss_twiddle_cpx( 0.75183981f, 0.65934582f ),
		new Jkiss_twiddle_cpx( 0.76040597f, 0.64944805f ), new Jkiss_twiddle_cpx( 0.76884183f, 0.63943900f ),
		new Jkiss_twiddle_cpx( 0.77714596f, 0.62932039f ), new Jkiss_twiddle_cpx( 0.78531693f, 0.61909395f ),
		new Jkiss_twiddle_cpx( 0.79335334f, 0.60876143f ), new Jkiss_twiddle_cpx( 0.80125381f, 0.59832460f ),
		new Jkiss_twiddle_cpx( 0.80901699f, 0.58778525f ), new Jkiss_twiddle_cpx( 0.81664156f, 0.57714519f ),
		new Jkiss_twiddle_cpx( 0.82412619f, 0.56640624f ), new Jkiss_twiddle_cpx( 0.83146961f, 0.55557023f ),
		new Jkiss_twiddle_cpx( 0.83867057f, 0.54463904f ), new Jkiss_twiddle_cpx( 0.84572782f, 0.53361452f ),
		new Jkiss_twiddle_cpx( 0.85264016f, 0.52249856f ), new Jkiss_twiddle_cpx( 0.85940641f, 0.51129309f ),
		new Jkiss_twiddle_cpx( 0.86602540f, 0.50000000f ), new Jkiss_twiddle_cpx( 0.87249601f, 0.48862124f ),
		new Jkiss_twiddle_cpx( 0.87881711f, 0.47715876f ), new Jkiss_twiddle_cpx( 0.88498764f, 0.46561452f ),
		new Jkiss_twiddle_cpx( 0.89100652f, 0.45399050f ), new Jkiss_twiddle_cpx( 0.89687274f, 0.44228869f ),
		new Jkiss_twiddle_cpx( 0.90258528f, 0.43051110f ), new Jkiss_twiddle_cpx( 0.90814317f, 0.41865974f ),
		new Jkiss_twiddle_cpx( 0.91354546f, 0.40673664f ), new Jkiss_twiddle_cpx( 0.91879121f, 0.39474386f ),
		new Jkiss_twiddle_cpx( 0.92387953f, 0.38268343f ), new Jkiss_twiddle_cpx( 0.92880955f, 0.37055744f ),
		new Jkiss_twiddle_cpx( 0.93358043f, 0.35836795f ), new Jkiss_twiddle_cpx( 0.93819134f, 0.34611706f ),
		new Jkiss_twiddle_cpx( 0.94264149f, 0.33380686f ), new Jkiss_twiddle_cpx( 0.94693013f, 0.32143947f ),
		new Jkiss_twiddle_cpx( 0.95105652f, 0.30901699f ), new Jkiss_twiddle_cpx( 0.95501994f, 0.29654157f ),
		new Jkiss_twiddle_cpx( 0.95881973f, 0.28401534f ), new Jkiss_twiddle_cpx( 0.96245524f, 0.27144045f ),
		new Jkiss_twiddle_cpx( 0.96592583f, 0.25881905f ), new Jkiss_twiddle_cpx( 0.96923091f, 0.24615329f ),
		new Jkiss_twiddle_cpx( 0.97236992f, 0.23344536f ), new Jkiss_twiddle_cpx( 0.97534232f, 0.22069744f ),
		new Jkiss_twiddle_cpx( 0.97814760f, 0.20791169f ), new Jkiss_twiddle_cpx( 0.98078528f, 0.19509032f ),
		new Jkiss_twiddle_cpx( 0.98325491f, 0.18223553f ), new Jkiss_twiddle_cpx( 0.98555606f, 0.16934950f ),
		new Jkiss_twiddle_cpx( 0.98768834f, 0.15643447f ), new Jkiss_twiddle_cpx( 0.98965139f, 0.14349262f ),
		new Jkiss_twiddle_cpx( 0.99144486f, 0.13052619f ), new Jkiss_twiddle_cpx( 0.99306846f, 0.11753740f ),
		new Jkiss_twiddle_cpx( 0.99452190f, 0.10452846f ), new Jkiss_twiddle_cpx( 0.99580493f, 0.091501619f ),
		new Jkiss_twiddle_cpx( 0.99691733f, 0.078459096f ), new Jkiss_twiddle_cpx( 0.99785892f, 0.065403129f ),
		new Jkiss_twiddle_cpx( 0.99862953f, 0.052335956f ), new Jkiss_twiddle_cpx( 0.99922904f, 0.039259816f ),
		new Jkiss_twiddle_cpx( 0.99965732f, 0.026176948f ), new Jkiss_twiddle_cpx( 0.99991433f, 0.013089596f ),
		};
// #ifndef FFT_BITREV480
// #define FFT_BITREV480
	private static final short fft_bitrev480[/* 480 */] = {
		0, 96, 192, 288, 384, 32, 128, 224, 320, 416, 64, 160, 256, 352, 448,
		8, 104, 200, 296, 392, 40, 136, 232, 328, 424, 72, 168, 264, 360, 456,
		16, 112, 208, 304, 400, 48, 144, 240, 336, 432, 80, 176, 272, 368, 464,
		24, 120, 216, 312, 408, 56, 152, 248, 344, 440, 88, 184, 280, 376, 472,
		4, 100, 196, 292, 388, 36, 132, 228, 324, 420, 68, 164, 260, 356, 452,
		12, 108, 204, 300, 396, 44, 140, 236, 332, 428, 76, 172, 268, 364, 460,
		20, 116, 212, 308, 404, 52, 148, 244, 340, 436, 84, 180, 276, 372, 468,
		28, 124, 220, 316, 412, 60, 156, 252, 348, 444, 92, 188, 284, 380, 476,
		1, 97, 193, 289, 385, 33, 129, 225, 321, 417, 65, 161, 257, 353, 449,
		9, 105, 201, 297, 393, 41, 137, 233, 329, 425, 73, 169, 265, 361, 457,
		17, 113, 209, 305, 401, 49, 145, 241, 337, 433, 81, 177, 273, 369, 465,
		25, 121, 217, 313, 409, 57, 153, 249, 345, 441, 89, 185, 281, 377, 473,
		5, 101, 197, 293, 389, 37, 133, 229, 325, 421, 69, 165, 261, 357, 453,
		13, 109, 205, 301, 397, 45, 141, 237, 333, 429, 77, 173, 269, 365, 461,
		21, 117, 213, 309, 405, 53, 149, 245, 341, 437, 85, 181, 277, 373, 469,
		29, 125, 221, 317, 413, 61, 157, 253, 349, 445, 93, 189, 285, 381, 477,
		2, 98, 194, 290, 386, 34, 130, 226, 322, 418, 66, 162, 258, 354, 450,
		10, 106, 202, 298, 394, 42, 138, 234, 330, 426, 74, 170, 266, 362, 458,
		18, 114, 210, 306, 402, 50, 146, 242, 338, 434, 82, 178, 274, 370, 466,
		26, 122, 218, 314, 410, 58, 154, 250, 346, 442, 90, 186, 282, 378, 474,
		6, 102, 198, 294, 390, 38, 134, 230, 326, 422, 70, 166, 262, 358, 454,
		14, 110, 206, 302, 398, 46, 142, 238, 334, 430, 78, 174, 270, 366, 462,
		22, 118, 214, 310, 406, 54, 150, 246, 342, 438, 86, 182, 278, 374, 470,
		30, 126, 222, 318, 414, 62, 158, 254, 350, 446, 94, 190, 286, 382, 478,
		3, 99, 195, 291, 387, 35, 131, 227, 323, 419, 67, 163, 259, 355, 451,
		11, 107, 203, 299, 395, 43, 139, 235, 331, 427, 75, 171, 267, 363, 459,
		19, 115, 211, 307, 403, 51, 147, 243, 339, 435, 83, 179, 275, 371, 467,
		27, 123, 219, 315, 411, 59, 155, 251, 347, 443, 91, 187, 283, 379, 475,
		7, 103, 199, 295, 391, 39, 135, 231, 327, 423, 71, 167, 263, 359, 455,
		15, 111, 207, 303, 399, 47, 143, 239, 335, 431, 79, 175, 271, 367, 463,
		23, 119, 215, 311, 407, 55, 151, 247, 343, 439, 87, 183, 279, 375, 471,
		31, 127, 223, 319, 415, 63, 159, 255, 351, 447, 95, 191, 287, 383, 479,
		};
// #endif

//#ifndef FFT_BITREV240
//#define FFT_BITREV240
	private static final short fft_bitrev240[/* 240 */] = {
		0, 48, 96, 144, 192, 16, 64, 112, 160, 208, 32, 80, 128, 176, 224,
		4, 52, 100, 148, 196, 20, 68, 116, 164, 212, 36, 84, 132, 180, 228,
		8, 56, 104, 152, 200, 24, 72, 120, 168, 216, 40, 88, 136, 184, 232,
		12, 60, 108, 156, 204, 28, 76, 124, 172, 220, 44, 92, 140, 188, 236,
		1, 49, 97, 145, 193, 17, 65, 113, 161, 209, 33, 81, 129, 177, 225,
		5, 53, 101, 149, 197, 21, 69, 117, 165, 213, 37, 85, 133, 181, 229,
		9, 57, 105, 153, 201, 25, 73, 121, 169, 217, 41, 89, 137, 185, 233,
		13, 61, 109, 157, 205, 29, 77, 125, 173, 221, 45, 93, 141, 189, 237,
		2, 50, 98, 146, 194, 18, 66, 114, 162, 210, 34, 82, 130, 178, 226,
		6, 54, 102, 150, 198, 22, 70, 118, 166, 214, 38, 86, 134, 182, 230,
		10, 58, 106, 154, 202, 26, 74, 122, 170, 218, 42, 90, 138, 186, 234,
		14, 62, 110, 158, 206, 30, 78, 126, 174, 222, 46, 94, 142, 190, 238,
		3, 51, 99, 147, 195, 19, 67, 115, 163, 211, 35, 83, 131, 179, 227,
		7, 55, 103, 151, 199, 23, 71, 119, 167, 215, 39, 87, 135, 183, 231,
		11, 59, 107, 155, 203, 27, 75, 123, 171, 219, 43, 91, 139, 187, 235,
		15, 63, 111, 159, 207, 31, 79, 127, 175, 223, 47, 95, 143, 191, 239,
		};
// #endif

// #ifndef FFT_BITREV120
// #define FFT_BITREV120
	private static final short fft_bitrev120[/* 120 */] = {
		0, 24, 48, 72, 96, 8, 32, 56, 80, 104, 16, 40, 64, 88, 112,
		4, 28, 52, 76, 100, 12, 36, 60, 84, 108, 20, 44, 68, 92, 116,
		1, 25, 49, 73, 97, 9, 33, 57, 81, 105, 17, 41, 65, 89, 113,
		5, 29, 53, 77, 101, 13, 37, 61, 85, 109, 21, 45, 69, 93, 117,
		2, 26, 50, 74, 98, 10, 34, 58, 82, 106, 18, 42, 66, 90, 114,
		6, 30, 54, 78, 102, 14, 38, 62, 86, 110, 22, 46, 70, 94, 118,
		3, 27, 51, 75, 99, 11, 35, 59, 83, 107, 19, 43, 67, 91, 115,
		7, 31, 55, 79, 103, 15, 39, 63, 87, 111, 23, 47, 71, 95, 119,
		};
// #endif

// #ifndef FFT_BITREV60
// #define FFT_BITREV60
	private static final short fft_bitrev60[/* 60 */] = {
		0, 12, 24, 36, 48, 4, 16, 28, 40, 52, 8, 20, 32, 44, 56,
		1, 13, 25, 37, 49, 5, 17, 29, 41, 53, 9, 21, 33, 45, 57,
		2, 14, 26, 38, 50, 6, 18, 30, 42, 54, 10, 22, 34, 46, 58,
		3, 15, 27, 39, 51, 7, 19, 31, 43, 55, 11, 23, 35, 47, 59,
		};
// #endif

// #ifndef FFT_STATE48000_960_0
// #define FFT_STATE48000_960_0
	private static final Jkiss_fft_state fft_state48000_960_0 = new Jkiss_fft_state(
		480,    /* nfft */
		0.002083333f,   /* scale */
		-1,     /* shift */
		new short[] {5, 96, 3, 32, 4, 8, 2, 4, 4, 1, 0, 0, 0, 0, 0, 0, },   /* factors */
		fft_bitrev480,  /* bitrev */
		fft_twiddles48000_960  /* bitrev */
/* #ifdef OVERRIDE_FFT
		(arch_fft_state *)&cfg_arch_480,
#else
		null
#endif */
	);
// #endif

// #ifndef FFT_STATE48000_960_1
// #define FFT_STATE48000_960_1
	static final Jkiss_fft_state fft_state48000_960_1 = new Jkiss_fft_state (
		240,    /* nfft */
		0.004166667f,   /* scale */
		1,      /* shift */
		new short[] {5, 48, 3, 16, 4, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, },    /* factors */
		fft_bitrev240,  /* bitrev */
		fft_twiddles48000_960  /* bitrev */
/* #ifdef OVERRIDE_FFT
		(arch_fft_state *)&cfg_arch_240,
#else
		null
#endif */
	);
// #endif

// #ifndef FFT_STATE48000_960_2
// #define FFT_STATE48000_960_2
	private static final Jkiss_fft_state fft_state48000_960_2 = new Jkiss_fft_state (
		120,    /* nfft */
		0.008333333f,   /* scale */
		2,      /* shift */
		new short[] {5, 24, 3, 8, 2, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, },    /* factors */
		fft_bitrev120,  /* bitrev */
		fft_twiddles48000_960  /* bitrev */
/* #ifdef OVERRIDE_FFT
		(arch_fft_state *)&cfg_arch_120,
#else
		null
#endif */
	);
// #endif

// #ifndef FFT_STATE48000_960_3
// #define FFT_STATE48000_960_3
	private static final Jkiss_fft_state fft_state48000_960_3 = new Jkiss_fft_state(
		60,     /* nfft */
		0.016666667f,   /* scale */
		3,      /* shift */
		new short[] {5, 12, 3, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, },    /* factors */
		fft_bitrev60,   /* bitrev */
		fft_twiddles48000_960  /* bitrev */
/* #ifdef OVERRIDE_FFT
		(arch_fft_state *)&cfg_arch_60,
#else
		null
#endif */
	);
// #endif

// #endif

// #ifndef MDCT_TWIDDLES960
// #define MDCT_TWIDDLES960
	private static final float mdct_twiddles960[/* 1800 */] = {
		0.99999994f, 0.99999321f, 0.99997580f, 0.99994773f, 0.99990886f,
		0.99985933f, 0.99979913f, 0.99972820f, 0.99964654f, 0.99955416f,
		0.99945110f, 0.99933738f, 0.99921292f, 0.99907774f, 0.99893188f,
		0.99877530f, 0.99860805f, 0.99843007f, 0.99824142f, 0.99804211f,
		0.99783206f, 0.99761140f, 0.99737996f, 0.99713790f, 0.99688518f,
		0.99662173f, 0.99634761f, 0.99606287f, 0.99576741f, 0.99546129f,
		0.99514455f, 0.99481714f, 0.99447906f, 0.99413031f, 0.99377096f,
		0.99340093f, 0.99302030f, 0.99262899f, 0.99222708f, 0.99181455f,
		0.99139136f, 0.99095762f, 0.99051321f, 0.99005818f, 0.98959261f,
		0.98911643f, 0.98862964f, 0.98813224f, 0.98762429f, 0.98710573f,
		0.98657662f, 0.98603696f, 0.98548669f, 0.98492593f, 0.98435456f,
		0.98377270f, 0.98318028f, 0.98257732f, 0.98196387f, 0.98133987f,
		0.98070538f, 0.98006040f, 0.97940493f, 0.97873890f, 0.97806245f,
		0.97737551f, 0.97667813f, 0.97597027f, 0.97525197f, 0.97452319f,
		0.97378403f, 0.97303438f, 0.97227436f, 0.97150391f, 0.97072303f,
		0.96993178f, 0.96913016f, 0.96831810f, 0.96749574f, 0.96666300f,
		0.96581990f, 0.96496642f, 0.96410263f, 0.96322852f, 0.96234411f,
		0.96144938f, 0.96054435f, 0.95962906f, 0.95870346f, 0.95776761f,
		0.95682150f, 0.95586514f, 0.95489854f, 0.95392174f, 0.95293468f,
		0.95193744f, 0.95093000f, 0.94991243f, 0.94888461f, 0.94784665f,
		0.94679856f, 0.94574034f, 0.94467193f, 0.94359344f, 0.94250488f,
		0.94140619f, 0.94029742f, 0.93917859f, 0.93804967f, 0.93691075f,
		0.93576175f, 0.93460274f, 0.93343377f, 0.93225473f, 0.93106574f,
		0.92986679f, 0.92865789f, 0.92743903f, 0.92621022f, 0.92497152f,
		0.92372292f, 0.92246443f, 0.92119598f, 0.91991776f, 0.91862965f,
		0.91733170f, 0.91602397f, 0.91470635f, 0.91337901f, 0.91204184f,
		0.91069490f, 0.90933824f, 0.90797186f, 0.90659571f, 0.90520984f,
		0.90381432f, 0.90240908f, 0.90099424f, 0.89956969f, 0.89813554f,
		0.89669174f, 0.89523834f, 0.89377540f, 0.89230281f, 0.89082074f,
		0.88932908f, 0.88782793f, 0.88631725f, 0.88479710f, 0.88326746f,
		0.88172835f, 0.88017982f, 0.87862182f, 0.87705445f, 0.87547767f,
		0.87389153f, 0.87229604f, 0.87069118f, 0.86907703f, 0.86745358f,
		0.86582077f, 0.86417878f, 0.86252749f, 0.86086690f, 0.85919720f,
		0.85751826f, 0.85583007f, 0.85413277f, 0.85242635f, 0.85071075f,
		0.84898609f, 0.84725231f, 0.84550947f, 0.84375757f, 0.84199661f,
		0.84022665f, 0.83844769f, 0.83665979f, 0.83486289f, 0.83305705f,
		0.83124226f, 0.82941860f, 0.82758605f, 0.82574469f, 0.82389444f,
		0.82203537f, 0.82016748f, 0.81829083f, 0.81640542f, 0.81451124f,
		0.81260836f, 0.81069672f, 0.80877650f, 0.80684757f, 0.80490994f,
		0.80296379f, 0.80100900f, 0.79904562f, 0.79707366f, 0.79509324f,
		0.79310423f, 0.79110676f, 0.78910083f, 0.78708643f, 0.78506362f,
		0.78303236f, 0.78099275f, 0.77894479f, 0.77688843f, 0.77482378f,
		0.77275085f, 0.77066964f, 0.76858020f, 0.76648247f, 0.76437658f,
		0.76226246f, 0.76014024f, 0.75800985f, 0.75587130f, 0.75372469f,
		0.75157005f, 0.74940729f, 0.74723655f, 0.74505776f, 0.74287105f,
		0.74067634f, 0.73847371f, 0.73626316f, 0.73404479f, 0.73181850f,
		0.72958434f, 0.72734243f, 0.72509271f, 0.72283524f, 0.72057003f,
		0.71829706f, 0.71601641f, 0.71372813f, 0.71143216f, 0.70912862f,
		0.70681745f, 0.70449871f, 0.70217246f, 0.69983864f, 0.69749737f,
		0.69514859f, 0.69279242f, 0.69042879f, 0.68805778f, 0.68567938f,
		0.68329364f, 0.68090063f, 0.67850029f, 0.67609268f, 0.67367786f,
		0.67125577f, 0.66882652f, 0.66639012f, 0.66394657f, 0.66149592f,
		0.65903819f, 0.65657341f, 0.65410155f, 0.65162271f, 0.64913690f,
		0.64664418f, 0.64414448f, 0.64163786f, 0.63912445f, 0.63660413f,
		0.63407701f, 0.63154310f, 0.62900239f, 0.62645501f, 0.62390089f,
		0.62134010f, 0.61877263f, 0.61619854f, 0.61361790f, 0.61103064f,
		0.60843682f, 0.60583651f, 0.60322970f, 0.60061646f, 0.59799677f,
		0.59537065f, 0.59273821f, 0.59009939f, 0.58745426f, 0.58480281f,
		0.58214509f, 0.57948118f, 0.57681108f, 0.57413477f, 0.57145232f,
		0.56876373f, 0.56606907f, 0.56336832f, 0.56066155f, 0.55794877f,
		0.55523002f, 0.55250537f, 0.54977477f, 0.54703826f, 0.54429591f,
		0.54154772f, 0.53879374f, 0.53603399f, 0.53326851f, 0.53049731f,
		0.52772039f, 0.52493787f, 0.52214974f, 0.51935595f, 0.51655668f,
		0.51375180f, 0.51094145f, 0.50812566f, 0.50530440f, 0.50247771f,
		0.49964568f, 0.49680826f, 0.49396557f, 0.49111754f, 0.48826426f,
		0.48540577f, 0.48254207f, 0.47967321f, 0.47679919f, 0.47392011f,
		0.47103590f, 0.46814668f, 0.46525243f, 0.46235323f, 0.45944905f,
		0.45653993f, 0.45362595f, 0.45070711f, 0.44778344f, 0.44485497f,
		0.44192174f, 0.43898380f, 0.43604112f, 0.43309379f, 0.43014181f,
		0.42718524f, 0.42422408f, 0.42125839f, 0.41828820f, 0.41531351f,
		0.41233435f, 0.40935081f, 0.40636289f, 0.40337059f, 0.40037400f,
		0.39737311f, 0.39436796f, 0.39135858f, 0.38834500f, 0.38532731f,
		0.38230544f, 0.37927949f, 0.37624949f, 0.37321547f, 0.37017745f,
		0.36713544f, 0.36408952f, 0.36103970f, 0.35798600f, 0.35492846f,
		0.35186714f, 0.34880206f, 0.34573323f, 0.34266070f, 0.33958447f,
		0.33650464f, 0.33342120f, 0.33033419f, 0.32724363f, 0.32414958f,
		0.32105204f, 0.31795108f, 0.31484672f, 0.31173897f, 0.30862790f,
		0.30551350f, 0.30239585f, 0.29927495f, 0.29615086f, 0.29302359f,
		0.28989318f, 0.28675964f, 0.28362307f, 0.28048345f, 0.27734083f,
		0.27419522f, 0.27104670f, 0.26789525f, 0.26474094f, 0.26158381f,
		0.25842386f, 0.25526115f, 0.25209570f, 0.24892756f, 0.24575676f,
		0.24258332f, 0.23940729f, 0.23622867f, 0.23304754f, 0.22986393f,
		0.22667783f, 0.22348931f, 0.22029841f, 0.21710514f, 0.21390954f,
		0.21071166f, 0.20751151f, 0.20430915f, 0.20110460f, 0.19789790f,
		0.19468907f, 0.19147816f, 0.18826519f, 0.18505022f, 0.18183327f,
		0.17861435f, 0.17539354f, 0.17217083f, 0.16894630f, 0.16571994f,
		0.16249183f, 0.15926196f, 0.15603039f, 0.15279715f, 0.14956227f,
		0.14632578f, 0.14308774f, 0.13984816f, 0.13660708f, 0.13336454f,
		0.13012058f, 0.12687522f, 0.12362850f, 0.12038045f, 0.11713112f,
		0.11388054f, 0.11062872f, 0.10737573f, 0.10412160f, 0.10086634f,
		0.097609997f, 0.094352618f, 0.091094226f, 0.087834857f, 0.084574550f,
		0.081313334f, 0.078051247f, 0.074788325f, 0.071524605f, 0.068260118f,
		0.064994894f, 0.061728980f, 0.058462404f, 0.055195201f, 0.051927410f,
		0.048659060f, 0.045390189f, 0.042120833f, 0.038851023f, 0.035580799f,
		0.032310195f, 0.029039243f, 0.025767982f, 0.022496443f, 0.019224664f,
		0.015952680f, 0.012680525f, 0.0094082337f, 0.0061358409f, 0.0028633832f,
		-0.00040910527f, -0.0036815894f, -0.0069540343f, -0.010226404f, -0.013498665f,
		-0.016770782f, -0.020042717f, -0.023314439f, -0.026585912f, -0.029857099f,
		-0.033127967f, -0.036398482f, -0.039668605f, -0.042938303f, -0.046207540f,
		-0.049476285f, -0.052744497f, -0.056012146f, -0.059279196f, -0.062545612f,
		-0.065811358f, -0.069076397f, -0.072340697f, -0.075604223f, -0.078866936f,
		-0.082128808f, -0.085389800f, -0.088649876f, -0.091909006f, -0.095167145f,
		-0.098424271f, -0.10168034f, -0.10493532f, -0.10818918f, -0.11144188f,
		-0.11469338f, -0.11794366f, -0.12119267f, -0.12444039f, -0.12768677f,
		-0.13093179f, -0.13417540f, -0.13741758f, -0.14065829f, -0.14389749f,
		-0.14713514f, -0.15037122f, -0.15360570f, -0.15683852f, -0.16006967f,
		-0.16329910f, -0.16652679f, -0.16975269f, -0.17297678f, -0.17619900f,
		-0.17941935f, -0.18263777f, -0.18585424f, -0.18906870f, -0.19228116f,
		-0.19549155f, -0.19869985f, -0.20190603f, -0.20511003f, -0.20831184f,
		-0.21151142f, -0.21470875f, -0.21790376f, -0.22109644f, -0.22428675f,
		-0.22747467f, -0.23066014f, -0.23384315f, -0.23702365f, -0.24020162f,
		-0.24337701f, -0.24654980f, -0.24971995f, -0.25288740f, -0.25605217f,
		-0.25921419f, -0.26237345f, -0.26552987f, -0.26868346f, -0.27183419f,
		-0.27498198f, -0.27812684f, -0.28126872f, -0.28440759f, -0.28754342f,
		-0.29067615f, -0.29380578f, -0.29693225f, -0.30005556f, -0.30317566f,
		-0.30629250f, -0.30940607f, -0.31251630f, -0.31562322f, -0.31872672f,
		-0.32182685f, -0.32492352f, -0.32801670f, -0.33110636f, -0.33419248f,
		-0.33727503f, -0.34035397f, -0.34342924f, -0.34650084f, -0.34956875f,
		-0.35263291f, -0.35569328f, -0.35874987f, -0.36180258f, -0.36485144f,
		-0.36789638f, -0.37093741f, -0.37397444f, -0.37700745f, -0.38003644f,
		-0.38306138f, -0.38608220f, -0.38909888f, -0.39211139f, -0.39511973f,
		-0.39812380f, -0.40112361f, -0.40411916f, -0.40711036f, -0.41009718f,
		-0.41307965f, -0.41605768f, -0.41903123f, -0.42200032f, -0.42496487f,
		-0.42792490f, -0.43088034f, -0.43383113f, -0.43677729f, -0.43971881f,
		-0.44265559f, -0.44558764f, -0.44851488f, -0.45143735f, -0.45435500f,
		-0.45726776f, -0.46017563f, -0.46307856f, -0.46597654f, -0.46886954f,
		-0.47175750f, -0.47464043f, -0.47751826f, -0.48039100f, -0.48325855f,
		-0.48612097f, -0.48897815f, -0.49183011f, -0.49467680f, -0.49751821f,
		-0.50035429f, -0.50318497f, -0.50601029f, -0.50883019f, -0.51164466f,
		-0.51445359f, -0.51725709f, -0.52005500f, -0.52284735f, -0.52563411f,
		-0.52841520f, -0.53119069f, -0.53396046f, -0.53672451f, -0.53948283f,
		-0.54223537f, -0.54498214f, -0.54772300f, -0.55045801f, -0.55318713f,
		-0.55591035f, -0.55862761f, -0.56133890f, -0.56404412f, -0.56674337f,
		-0.56943649f, -0.57212353f, -0.57480448f, -0.57747924f, -0.58014780f,
		-0.58281022f, -0.58546633f, -0.58811617f, -0.59075975f, -0.59339696f,
		-0.59602785f, -0.59865236f, -0.60127044f, -0.60388207f, -0.60648727f,
		-0.60908598f, -0.61167812f, -0.61426371f, -0.61684275f, -0.61941516f,
		-0.62198097f, -0.62454009f, -0.62709254f, -0.62963831f, -0.63217729f,
		-0.63470948f, -0.63723493f, -0.63975352f, -0.64226526f, -0.64477009f,
		-0.64726806f, -0.64975911f, -0.65224314f, -0.65472025f, -0.65719032f,
		-0.65965337f, -0.66210932f, -0.66455823f, -0.66700000f, -0.66943461f,
		-0.67186207f, -0.67428231f, -0.67669535f, -0.67910111f, -0.68149966f,
		-0.68389088f, -0.68627477f, -0.68865126f, -0.69102043f, -0.69338220f,
		-0.69573659f, -0.69808346f, -0.70042288f, -0.70275480f, -0.70507920f,
		-0.70739603f, -0.70970529f, -0.71200693f, -0.71430099f, -0.71658736f,
		-0.71886611f, -0.72113711f, -0.72340041f, -0.72565591f, -0.72790372f,
		-0.73014367f, -0.73237586f, -0.73460019f, -0.73681659f, -0.73902518f,
		-0.74122584f, -0.74341851f, -0.74560326f, -0.74778003f, -0.74994880f,
		-0.75210953f, -0.75426215f, -0.75640678f, -0.75854325f, -0.76067162f,
		-0.76279181f, -0.76490390f, -0.76700771f, -0.76910341f, -0.77119076f,
		-0.77326995f, -0.77534080f, -0.77740335f, -0.77945763f, -0.78150350f,
		-0.78354102f, -0.78557014f, -0.78759086f, -0.78960317f, -0.79160696f,
		-0.79360235f, -0.79558921f, -0.79756755f, -0.79953730f, -0.80149853f,
		-0.80345118f, -0.80539525f, -0.80733067f, -0.80925739f, -0.81117553f,
		-0.81308490f, -0.81498563f, -0.81687760f, -0.81876087f, -0.82063532f,
		-0.82250100f, -0.82435787f, -0.82620591f, -0.82804507f, -0.82987541f,
		-0.83169687f, -0.83350939f, -0.83531296f, -0.83710766f, -0.83889335f,
		-0.84067005f, -0.84243774f, -0.84419644f, -0.84594607f, -0.84768665f,
		-0.84941816f, -0.85114056f, -0.85285389f, -0.85455805f, -0.85625303f,
		-0.85793889f, -0.85961550f, -0.86128294f, -0.86294121f, -0.86459017f,
		-0.86622989f, -0.86786032f, -0.86948150f, -0.87109333f, -0.87269586f,
		-0.87428904f, -0.87587279f, -0.87744725f, -0.87901229f, -0.88056785f,
		-0.88211405f, -0.88365078f, -0.88517809f, -0.88669586f, -0.88820416f,
		-0.88970292f, -0.89119220f, -0.89267188f, -0.89414203f, -0.89560264f,
		-0.89705360f, -0.89849502f, -0.89992678f, -0.90134889f, -0.90276134f,
		-0.90416414f, -0.90555727f, -0.90694070f, -0.90831441f, -0.90967834f,
		-0.91103262f, -0.91237706f, -0.91371179f, -0.91503674f, -0.91635185f,
		-0.91765714f, -0.91895264f, -0.92023826f, -0.92151409f, -0.92277998f,
		-0.92403603f, -0.92528218f, -0.92651838f, -0.92774469f, -0.92896110f,
		-0.93016750f, -0.93136400f, -0.93255049f, -0.93372697f, -0.93489349f,
		-0.93604994f, -0.93719643f, -0.93833286f, -0.93945926f, -0.94057560f,
		-0.94168180f, -0.94277799f, -0.94386405f, -0.94494003f, -0.94600588f,
		-0.94706154f, -0.94810712f, -0.94914252f, -0.95016778f, -0.95118284f,
		-0.95218778f, -0.95318246f, -0.95416695f, -0.95514119f, -0.95610523f,
		-0.95705903f, -0.95800257f, -0.95893586f, -0.95985889f, -0.96077162f,
		-0.96167403f, -0.96256620f, -0.96344805f, -0.96431959f, -0.96518075f,
		-0.96603161f, -0.96687216f, -0.96770233f, -0.96852213f, -0.96933156f,
		-0.97013056f, -0.97091925f, -0.97169751f, -0.97246534f, -0.97322279f,
		-0.97396982f, -0.97470641f, -0.97543252f, -0.97614825f, -0.97685349f,
		-0.97754824f, -0.97823256f, -0.97890645f, -0.97956979f, -0.98022264f,
		-0.98086500f, -0.98149687f, -0.98211825f, -0.98272908f, -0.98332942f,
		-0.98391914f, -0.98449844f, -0.98506713f, -0.98562527f, -0.98617285f,
		-0.98670989f, -0.98723638f, -0.98775226f, -0.98825759f, -0.98875231f,
		-0.98923647f, -0.98971003f, -0.99017298f, -0.99062532f, -0.99106705f,
		-0.99149817f, -0.99191868f, -0.99232858f, -0.99272782f, -0.99311644f,
		-0.99349445f, -0.99386179f, -0.99421853f, -0.99456459f, -0.99489999f,
		-0.99522477f, -0.99553883f, -0.99584228f, -0.99613506f, -0.99641716f,
		-0.99668860f, -0.99694937f, -0.99719942f, -0.99743885f, -0.99766755f,
		-0.99788558f, -0.99809295f, -0.99828959f, -0.99847561f, -0.99865085f,
		-0.99881548f, -0.99896932f, -0.99911255f, -0.99924499f, -0.99936682f,
		-0.99947786f, -0.99957830f, -0.99966794f, -0.99974692f, -0.99981517f,
		-0.99987274f, -0.99991959f, -0.99995571f, -0.99998116f, -0.99999589f,
		0.99999964f, 0.99997288f, 0.99990326f, 0.99979085f, 0.99963558f,
		0.99943751f, 0.99919659f, 0.99891287f, 0.99858636f, 0.99821711f,
		0.99780506f, 0.99735034f, 0.99685282f, 0.99631262f, 0.99572974f,
		0.99510419f, 0.99443603f, 0.99372530f, 0.99297196f, 0.99217612f,
		0.99133772f, 0.99045694f, 0.98953366f, 0.98856801f, 0.98756003f,
		0.98650974f, 0.98541719f, 0.98428243f, 0.98310548f, 0.98188645f,
		0.98062533f, 0.97932225f, 0.97797716f, 0.97659022f, 0.97516143f,
		0.97369087f, 0.97217858f, 0.97062469f, 0.96902919f, 0.96739221f,
		0.96571374f, 0.96399397f, 0.96223283f, 0.96043050f, 0.95858705f,
		0.95670253f, 0.95477700f, 0.95281059f, 0.95080340f, 0.94875544f,
		0.94666684f, 0.94453770f, 0.94236809f, 0.94015813f, 0.93790787f,
		0.93561745f, 0.93328691f, 0.93091643f, 0.92850608f, 0.92605597f,
		0.92356616f, 0.92103678f, 0.91846794f, 0.91585976f, 0.91321236f,
		0.91052586f, 0.90780038f, 0.90503591f, 0.90223277f, 0.89939094f,
		0.89651060f, 0.89359182f, 0.89063478f, 0.88763964f, 0.88460642f,
		0.88153529f, 0.87842643f, 0.87527996f, 0.87209594f, 0.86887461f,
		0.86561602f, 0.86232042f, 0.85898781f, 0.85561842f, 0.85221243f,
		0.84876984f, 0.84529096f, 0.84177583f, 0.83822471f, 0.83463764f,
		0.83101481f, 0.82735640f, 0.82366252f, 0.81993335f, 0.81616908f,
		0.81236988f, 0.80853581f, 0.80466717f, 0.80076402f, 0.79682660f,
		0.79285502f, 0.78884947f, 0.78481019f, 0.78073722f, 0.77663082f,
		0.77249116f, 0.76831841f, 0.76411277f, 0.75987434f, 0.75560343f,
		0.75130010f, 0.74696463f, 0.74259710f, 0.73819780f, 0.73376691f,
		0.72930455f, 0.72481096f, 0.72028631f, 0.71573079f, 0.71114463f,
		0.70652801f, 0.70188117f, 0.69720417f, 0.69249737f, 0.68776089f,
		0.68299496f, 0.67819971f, 0.67337549f, 0.66852236f, 0.66364062f,
		0.65873051f, 0.65379208f, 0.64882571f, 0.64383155f, 0.63880974f,
		0.63376063f, 0.62868434f, 0.62358117f, 0.61845124f, 0.61329484f,
		0.60811216f, 0.60290343f, 0.59766883f, 0.59240872f, 0.58712316f,
		0.58181250f, 0.57647687f, 0.57111657f, 0.56573176f, 0.56032276f,
		0.55488980f, 0.54943299f, 0.54395270f, 0.53844911f, 0.53292239f,
		0.52737290f, 0.52180082f, 0.51620632f, 0.51058978f, 0.50495136f,
		0.49929130f, 0.49360985f, 0.48790723f, 0.48218375f, 0.47643960f,
		0.47067502f, 0.46489030f, 0.45908567f, 0.45326138f, 0.44741765f,
		0.44155475f, 0.43567297f, 0.42977250f, 0.42385364f, 0.41791660f,
		0.41196167f, 0.40598908f, 0.39999911f, 0.39399201f, 0.38796803f,
		0.38192743f, 0.37587047f, 0.36979741f, 0.36370850f, 0.35760403f,
		0.35148421f, 0.34534934f, 0.33919969f, 0.33303553f, 0.32685706f,
		0.32066461f, 0.31445843f, 0.30823877f, 0.30200592f, 0.29576012f,
		0.28950164f, 0.28323078f, 0.27694780f, 0.27065292f, 0.26434645f,
		0.25802869f, 0.25169984f, 0.24536023f, 0.23901010f, 0.23264973f,
		0.22627939f, 0.21989937f, 0.21350993f, 0.20711134f, 0.20070387f,
		0.19428782f, 0.18786344f, 0.18143101f, 0.17499080f, 0.16854310f,
		0.16208819f, 0.15562633f, 0.14915779f, 0.14268288f, 0.13620184f,
		0.12971498f, 0.12322257f, 0.11672486f, 0.11022217f, 0.10371475f,
		0.097202882f, 0.090686858f, 0.084166944f, 0.077643424f, 0.071116582f,
		0.064586692f, 0.058054037f, 0.051518895f, 0.044981543f, 0.038442269f,
		0.031901345f, 0.025359053f, 0.018815678f, 0.012271495f, 0.0057267868f,
		-0.00081816671f, -0.0073630852f, -0.013907688f, -0.020451695f, -0.026994826f,
		-0.033536803f, -0.040077340f, -0.046616159f, -0.053152986f, -0.059687532f,
		-0.066219524f, -0.072748676f, -0.079274714f, -0.085797355f, -0.092316322f,
		-0.098831341f, -0.10534211f, -0.11184838f, -0.11834986f, -0.12484626f,
		-0.13133731f, -0.13782275f, -0.14430228f, -0.15077563f, -0.15724251f,
		-0.16370267f, -0.17015581f, -0.17660165f, -0.18303993f, -0.18947038f,
		-0.19589271f, -0.20230664f, -0.20871192f, -0.21510825f, -0.22149536f,
		-0.22787298f, -0.23424086f, -0.24059868f, -0.24694622f, -0.25328314f,
		-0.25960925f, -0.26592422f, -0.27222782f, -0.27851975f, -0.28479972f,
		-0.29106751f, -0.29732284f, -0.30356544f, -0.30979502f, -0.31601134f,
		-0.32221413f, -0.32840309f, -0.33457801f, -0.34073856f, -0.34688455f,
		-0.35301566f, -0.35913166f, -0.36523229f, -0.37131724f, -0.37738630f,
		-0.38343921f, -0.38947567f, -0.39549544f, -0.40149832f, -0.40748394f,
		-0.41345215f, -0.41940263f, -0.42533514f, -0.43124944f, -0.43714526f,
		-0.44302234f, -0.44888046f, -0.45471936f, -0.46053877f, -0.46633846f,
		-0.47211814f, -0.47787762f, -0.48361665f, -0.48933494f, -0.49503228f,
		-0.50070840f, -0.50636309f, -0.51199609f, -0.51760709f, -0.52319598f,
		-0.52876246f, -0.53430629f, -0.53982723f, -0.54532504f, -0.55079949f,
		-0.55625033f, -0.56167740f, -0.56708032f, -0.57245898f, -0.57781315f,
		-0.58314258f, -0.58844697f, -0.59372622f, -0.59897995f, -0.60420811f,
		-0.60941035f, -0.61458647f, -0.61973625f, -0.62485951f, -0.62995601f,
		-0.63502556f, -0.64006782f, -0.64508271f, -0.65007001f, -0.65502942f,
		-0.65996075f, -0.66486382f, -0.66973841f, -0.67458433f, -0.67940134f,
		-0.68418926f, -0.68894786f, -0.69367695f, -0.69837630f, -0.70304573f,
		-0.70768511f, -0.71229410f, -0.71687263f, -0.72142041f, -0.72593731f,
		-0.73042315f, -0.73487765f, -0.73930067f, -0.74369204f, -0.74805158f,
		-0.75237900f, -0.75667429f, -0.76093709f, -0.76516730f, -0.76936477f,
		-0.77352923f, -0.77766061f, -0.78175867f, -0.78582323f, -0.78985411f,
		-0.79385114f, -0.79781419f, -0.80174309f, -0.80563760f, -0.80949765f,
		-0.81332302f, -0.81711352f, -0.82086903f, -0.82458937f, -0.82827437f,
		-0.83192390f, -0.83553779f, -0.83911592f, -0.84265804f, -0.84616417f,
		-0.84963393f, -0.85306740f, -0.85646427f, -0.85982448f, -0.86314780f,
		-0.86643422f, -0.86968350f, -0.87289548f, -0.87607014f, -0.87920725f,
		-0.88230664f, -0.88536829f, -0.88839203f, -0.89137769f, -0.89432514f,
		-0.89723432f, -0.90010506f, -0.90293723f, -0.90573072f, -0.90848541f,
		-0.91120118f, -0.91387796f, -0.91651553f, -0.91911387f, -0.92167282f,
		-0.92419231f, -0.92667222f, -0.92911243f, -0.93151283f, -0.93387336f,
		-0.93619382f, -0.93847424f, -0.94071442f, -0.94291431f, -0.94507378f,
		-0.94719279f, -0.94927126f, -0.95130903f, -0.95330608f, -0.95526224f,
		-0.95717752f, -0.95905179f, -0.96088499f, -0.96267700f, -0.96442777f,
		-0.96613729f, -0.96780539f, -0.96943200f, -0.97101706f, -0.97256058f,
		-0.97406244f, -0.97552258f, -0.97694093f, -0.97831738f, -0.97965199f,
		-0.98094457f, -0.98219514f, -0.98340368f, -0.98457009f, -0.98569429f,
		-0.98677629f, -0.98781598f, -0.98881340f, -0.98976845f, -0.99068111f,
		-0.99155134f, -0.99237907f, -0.99316430f, -0.99390697f, -0.99460709f,
		-0.99526459f, -0.99587947f, -0.99645168f, -0.99698120f, -0.99746799f,
		-0.99791211f, -0.99831343f, -0.99867201f, -0.99898779f, -0.99926084f,
		-0.99949104f, -0.99967843f, -0.99982297f, -0.99992472f, -0.99998361f,
		0.99999869f, 0.99989158f, 0.99961317f, 0.99916345f, 0.99854255f,
		0.99775058f, 0.99678761f, 0.99565387f, 0.99434954f, 0.99287480f,
		0.99122995f, 0.98941529f, 0.98743105f, 0.98527765f, 0.98295540f,
		0.98046476f, 0.97780609f, 0.97497988f, 0.97198665f, 0.96882683f,
		0.96550101f, 0.96200979f, 0.95835376f, 0.95453346f, 0.95054960f,
		0.94640291f, 0.94209403f, 0.93762374f, 0.93299282f, 0.92820197f,
		0.92325211f, 0.91814411f, 0.91287869f, 0.90745693f, 0.90187967f,
		0.89614785f, 0.89026248f, 0.88422459f, 0.87803519f, 0.87169534f,
		0.86520612f, 0.85856867f, 0.85178405f, 0.84485358f, 0.83777827f,
		0.83055943f, 0.82319832f, 0.81569612f, 0.80805415f, 0.80027372f,
		0.79235619f, 0.78430289f, 0.77611518f, 0.76779449f, 0.75934225f,
		0.75075996f, 0.74204898f, 0.73321080f, 0.72424710f, 0.71515924f,
		0.70594883f, 0.69661748f, 0.68716675f, 0.67759830f, 0.66791373f,
		0.65811473f, 0.64820296f, 0.63818014f, 0.62804794f, 0.61780810f,
		0.60746247f, 0.59701276f, 0.58646071f, 0.57580817f, 0.56505698f,
		0.55420899f, 0.54326600f, 0.53222996f, 0.52110273f, 0.50988621f,
		0.49858227f, 0.48719296f, 0.47572014f, 0.46416581f, 0.45253196f,
		0.44082057f, 0.42903364f, 0.41717321f, 0.40524128f, 0.39323992f,
		0.38117120f, 0.36903715f, 0.35683987f, 0.34458145f, 0.33226398f,
		0.31988961f, 0.30746040f, 0.29497850f, 0.28244606f, 0.26986524f,
		0.25723818f, 0.24456702f, 0.23185398f, 0.21910121f, 0.20631088f,
		0.19348522f, 0.18062639f, 0.16773662f, 0.15481812f, 0.14187308f,
		0.12890373f, 0.11591230f, 0.10290100f, 0.089872077f, 0.076827750f,
		0.063770257f, 0.050701842f, 0.037624735f, 0.024541186f, 0.011453429f,
		-0.0016362892f, -0.014725727f, -0.027812643f, -0.040894791f, -0.053969935f,
		-0.067035832f, -0.080090240f, -0.093130924f, -0.10615565f, -0.11916219f,
		-0.13214831f, -0.14511178f, -0.15805040f, -0.17096193f, -0.18384418f,
		-0.19669491f, -0.20951195f, -0.22229309f, -0.23503613f, -0.24773891f,
		-0.26039925f, -0.27301496f, -0.28558388f, -0.29810387f, -0.31057280f,
		-0.32298848f, -0.33534884f, -0.34765175f, -0.35989508f, -0.37207675f,
		-0.38419467f, -0.39624676f, -0.40823093f, -0.42014518f, -0.43198743f,
		-0.44375566f, -0.45544785f, -0.46706200f, -0.47859612f, -0.49004826f,
		-0.50141639f, -0.51269865f, -0.52389306f, -0.53499764f, -0.54601061f,
		-0.55693001f, -0.56775403f, -0.57848072f, -0.58910829f, -0.59963489f,
		-0.61005878f, -0.62037814f, -0.63059121f, -0.64069623f, -0.65069145f,
		-0.66057515f, -0.67034572f, -0.68000144f, -0.68954057f, -0.69896162f,
		-0.70826286f, -0.71744281f, -0.72649974f, -0.73543227f, -0.74423873f,
		-0.75291771f, -0.76146764f, -0.76988715f, -0.77817470f, -0.78632891f,
		-0.79434842f, -0.80223179f, -0.80997771f, -0.81758487f, -0.82505190f,
		-0.83237761f, -0.83956063f, -0.84659988f, -0.85349399f, -0.86024189f,
		-0.86684239f, -0.87329435f, -0.87959671f, -0.88574833f, -0.89174819f,
		-0.89759529f, -0.90328854f, -0.90882701f, -0.91420978f, -0.91943592f,
		-0.92450452f, -0.92941469f, -0.93416560f, -0.93875647f, -0.94318646f,
		-0.94745487f, -0.95156091f, -0.95550388f, -0.95928317f, -0.96289814f,
		-0.96634805f, -0.96963239f, -0.97275060f, -0.97570217f, -0.97848648f,
		-0.98110318f, -0.98355180f, -0.98583186f, -0.98794299f, -0.98988485f,
		-0.99165714f, -0.99325943f, -0.99469161f, -0.99595332f, -0.99704438f,
		-0.99796462f, -0.99871385f, -0.99929196f, -0.99969882f, -0.99993443f,
		0.99999464f, 0.99956632f, 0.99845290f, 0.99665523f, 0.99417448f,
		0.99101239f, 0.98717111f, 0.98265326f, 0.97746199f, 0.97160077f,
		0.96507365f, 0.95788515f, 0.95004016f, 0.94154406f, 0.93240267f,
		0.92262226f, 0.91220951f, 0.90117162f, 0.88951606f, 0.87725091f,
		0.86438453f, 0.85092574f, 0.83688372f, 0.82226819f, 0.80708915f,
		0.79135692f, 0.77508235f, 0.75827658f, 0.74095112f, 0.72311783f,
		0.70478898f, 0.68597710f, 0.66669506f, 0.64695615f, 0.62677377f,
		0.60616189f, 0.58513457f, 0.56370622f, 0.54189157f, 0.51970547f,
		0.49716324f, 0.47428027f, 0.45107225f, 0.42755505f, 0.40374488f,
		0.37965798f, 0.35531086f, 0.33072025f, 0.30590299f, 0.28087607f,
		0.25565663f, 0.23026201f, 0.20470956f, 0.17901683f, 0.15320139f,
		0.12728097f, 0.10127331f, 0.075196236f, 0.049067631f, 0.022905400f,
		-0.0032725304f, -0.029448219f, -0.055603724f, -0.081721120f, -0.10778251f,
		-0.13377003f, -0.15966587f, -0.18545228f, -0.21111161f, -0.23662624f,
		-0.26197869f, -0.28715160f, -0.31212771f, -0.33688989f, -0.36142120f,
		-0.38570482f, -0.40972409f, -0.43346253f, -0.45690393f, -0.48003218f,
		-0.50283146f, -0.52528608f, -0.54738069f, -0.56910020f, -0.59042966f,
		-0.61135447f, -0.63186026f, -0.65193301f, -0.67155898f, -0.69072473f,
		-0.70941705f, -0.72762316f, -0.74533063f, -0.76252723f, -0.77920127f,
		-0.79534131f, -0.81093621f, -0.82597536f, -0.84044844f, -0.85434550f,
		-0.86765707f, -0.88037395f, -0.89248747f, -0.90398932f, -0.91487163f,
		-0.92512697f, -0.93474823f, -0.94372886f, -0.95206273f, -0.95974404f,
		-0.96676767f, -0.97312868f, -0.97882277f, -0.98384601f, -0.98819500f,
		-0.99186671f, -0.99485862f, -0.99716878f, -0.99879545f, -0.99973762f,
	};
// #endif

	private static final JCELTMode mode48000_960_120 = new JCELTMode (
		48000,  /* Fs */
		120,    /* overlap */
		21,     /* nbEBands */
		21,     /* effEBands */
		new float[] { 0.85000610f, 0.0000000f, 1.0000000f, 1.0000000f, },    /* preemph */
		eband5ms,       /* eBands */
		3,      /* maxLM */
		8,      /* nbShortMdcts */
		120,    /* shortMdctSize */
		11,     /* nbAllocVectors */
		band_allocation,        /* allocVectors */
		logN400,        /* logN */
		window120,      /* window */
		new Jmdct_lookup(
				1920, 3,
				new Jkiss_fft_state[]
						{fft_state48000_960_0, fft_state48000_960_1, fft_state48000_960_2, fft_state48000_960_3, },
				mdct_twiddles960),    /* mdct */
		new JPulseCache( 392, cache_index50, cache_bits50, cache_caps50 )       /* cache */
	);

	/* List of all the available modes */
	private static final int TOTAL_MODES = 1;
	private static final JCELTMode static_mode_list[/* TOTAL_MODES */] = {
			mode48000_960_120,
	};
	// end static_modes_float.h
	//
	JCELTMode(final int iFs, final int ioverlap, final int inbEBands, final int ieffEBands, final float[] ipreemph,
			final short[] ieBands, final int imaxLM, final int inbShortMdcts, final int ishortMdctSize,
			final int inbAllocVectors, final char[] iallocVectors, final short[] ilogN, final float[] iwindow,
			final Jmdct_lookup imdct, final JPulseCache icache)
	{
		Fs = iFs;
		overlap = ioverlap;
		nbEBands = inbEBands;
		effEBands = ieffEBands;
		preemph[0] = ipreemph[0]; preemph[1] = ipreemph[1]; preemph[2] = ipreemph[2]; preemph[3] = ipreemph[3];
		eBands = ieBands;
		maxLM = imaxLM;
		nbShortMdcts = inbShortMdcts;
		shortMdctSize = ishortMdctSize;
		nbAllocVectors = inbAllocVectors;
		allocVectors = iallocVectors;
		logN = ilogN;
		window = iwindow;
		mdct.copyFrom( imdct );
		cache.copyFrom( icache );
	}
// modes.c

	/* private static final short eband5ms[] = {
			// 0  200 400 600 800  1k 1.2 1.4 1.6  2k 2.4 2.8 3.2  4k 4.8 5.6 6.8  8k 9.6 12k 15.6
			0,  1,  2,  3,  4,  5,  6,  7,  8, 10, 12, 14, 16, 20, 24, 28, 34, 40, 48, 60, 78, 100
	};*/

	/** Alternate tuning ( partially derived from Vorbis ) */
	// private static final int BITALLOC_SIZE = 11;
	/** Bit allocation table in units of 1 / 32 bit / sample ( 0.1875 dB SNR ) */
	/*private static final unsigned char band_allocation[] = {
		// 0  200 400 600 800  1k 1.2 1.4 1.6  2k 2.4 2.8 3.2  4k 4.8 5.6 6.8  8k 9.6 12k 15.6
		0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
		90, 80, 75, 69, 63, 56, 49, 40, 34, 29, 20, 18, 10,  0,  0,  0,  0,  0,  0,  0,  0,
		110,100, 90, 84, 78, 71, 65, 58, 51, 45, 39, 32, 26, 20, 12,  0,  0,  0,  0,  0,  0,
		118,110,103, 93, 86, 80, 75, 70, 65, 59, 53, 47, 40, 31, 23, 15,  4,  0,  0,  0,  0,
		126,119,112,104, 95, 89, 83, 78, 72, 66, 60, 54, 47, 39, 32, 25, 17, 12,  1,  0,  0,
		134,127,120,114,103, 97, 91, 85, 78, 72, 66, 60, 54, 47, 41, 35, 29, 23, 16, 10,  1,
		144,137,130,124,113,107,101, 95, 88, 82, 76, 70, 64, 57, 51, 45, 39, 33, 26, 15,  1,
		152,145,138,132,123,117,111,105, 98, 92, 86, 80, 74, 67, 61, 55, 49, 43, 36, 20,  1,
		162,155,148,142,133,127,121,115,108,102, 96, 90, 84, 77, 71, 65, 59, 53, 46, 30,  1,
		172,165,158,152,143,137,131,125,118,112,106,100, 94, 87, 81, 75, 69, 63, 56, 45, 20,
		200,200,200,200,200,200,200,200,198,193,188,183,178,173,168,163,158,153,148,129,104,
	};*/

// #ifdef CUSTOM_MODES

	/* Defining 25 critical bands for the full 0 - 20 kHz audio bandwidth
	   Taken from http://ccrma.stanford.edu/~jos/bbt/Bark_Frequency_Scale.html */
//	private static final int BARK_BANDS = 25;
//	private static final short bark_freq[/* BARK_BANDS + 1 */] = {
//		0,   100,   200,   300,   400,
//		510,   630,   770,   920,  1080,
//		1270,  1480,  1720,  2000,  2320,
//		2700,  3150,  3700,  4400,  5300,
//		6400,  7700,  9500, 12000, 15500,
//		20000};

/*	private static final short[] compute_ebands(int Fs, int frame_size, int res, int[] nbEBands)
	{
		opus_int16 * eBands;
		int i, j, lin, low, high, nBark, offset = 0;

		// All modes that have 2.5 ms short blocks use the same definition
		if( Fs == 400 * ( opus_int32 )frame_size )
		{
			* nbEBands = sizeof( eband5ms ) / sizeof( eband5ms[0] ) - 1;
			eBands = opus_alloc( sizeof( opus_int16 ) * ( * nbEBands + 1 ) );
			for( i = 0; i < *nbEBands + 1; i++ )
				eBands[i] = eband5ms[i];
			return eBands;
		}
		// Find the number of critical bands supported by our sampling rate
		for( nBark = 1; nBark < BARK_BANDS; nBark++ )
			if( bark_freq[nBark + 1] * 2 >= Fs )
				break;

		// Find where the linear part ends ( i.e. where the spacing is more than min_width
		for( lin = 0; lin < nBark; lin++ )
			if( bark_freq[lin + 1] - bark_freq[lin] >= res )
				break;

		low = ( bark_freq[lin] + res / 2 ) / res;
		high = nBark - lin;
		*nbEBands = low + high;
		eBands = opus_alloc( sizeof( opus_int16 ) * ( * nbEBands + 2 ) );

		if( eBands == NULL )
			return NULL;

		// Linear spacing ( min_width )
		for( i = 0; i < low; i++ )
			eBands[i] = i;
		if( low > 0 )
			offset = eBands[low - 1] * res - bark_freq[lin - 1];
		// Spacing follows critical bands
		for( i = 0; i < high; i++ )
		{
			int target = bark_freq[lin + i];
			// Round to an even value
			eBands[i + low] = ( target + offset / 2 + res ) / ( 2 * res ) * 2;
			offset = eBands[i + low] * res - target;
		}
		// Enforce the minimum spacing at the boundary
		for( i = 0; i < * nbEBands; i++ )
			if( eBands[i] < i )
				eBands[i] = i;
		// Round to an even value
		eBands[ * nbEBands] = ( bark_freq[nBark] + res ) / ( 2 * res ) * 2;
		if( eBands[ * nbEBands] > frame_size )
			eBands[ * nbEBands] = frame_size;
		for( i = 1; i < * nbEBands - 1; i++ )
		{
			if( eBands[i + 1] - eBands[i] < eBands[i] - eBands[i - 1] )
			{
				eBands[i] -= ( 2 * eBands[i] - eBands[i - 1] - eBands[i + 1] ) / 2;
			}
		}
		// Remove any empty bands.
		for( i = j = 0; i < * nbEBands; i++ )
			if( eBands[i + 1]>eBands[j] )
				eBands[++j] = eBands[i + 1];
		 * nbEBands = j;

		for( i = 1; i < * nbEBands; i++ )
		{
			// Every band must be smaller than the last band.
			celt_assert( eBands[i] - eBands[i - 1] <= eBands[ * nbEBands] - eBands[ * nbEBands - 1] );
			// Each band must be no larger than twice the size of the previous one.
			celt_assert( eBands[i + 1] - eBands[i] <= 2 * ( eBands[i] - eBands[i - 1] ) );
		}

		return eBands;
	}

	private static final void compute_allocation_table(JCELTMode mode )
	{
		int i, j;
		unsigned char * allocVectors;
		int maxBands = sizeof( eband5ms ) / sizeof( eband5ms[0] ) - 1;

		mode.nbAllocVectors = BITALLOC_SIZE;
		allocVectors = opus_alloc( sizeof( unsigned char ) * ( BITALLOC_SIZE * mode.nbEBands ) );
		if( allocVectors == NULL )
			return;

		// Check for standard mode
		if( mode.Fs == 400 * ( opus_int32 )mode.shortMdctSize )
		{
			for( i = 0; i < BITALLOC_SIZE * mode.nbEBands; i++ )
				allocVectors[i] = band_allocation[i];
			mode.allocVectors = allocVectors;
			return;
		}
		// If not the standard mode, interpolate
		// Compute per - codec - band allocation from per - critical - band matrix
		for( i = 0; i < BITALLOC_SIZE; i++ )
		{
			for( j = 0; j < mode.nbEBands; j++ )
			{
				int k;
				for( k = 0; k < maxBands; k++ )
				{
					if( 400 * ( opus_int32 )eband5ms[k] > mode.eBands[j] * ( opus_int32 )mode.Fs / mode.shortMdctSize )
						break;
				}
				if( k > maxBands - 1 )
					allocVectors[i * mode.nbEBands + j] = band_allocation[i * maxBands + maxBands - 1];
				else {
					opus_int32 a0, a1;
					a1 = mode.eBands[j] * ( opus_int32 )mode.Fs / mode.shortMdctSize - 400 * ( opus_int32 )eband5ms[k - 1];
					a0 = 400 * ( opus_int32 )eband5ms[k] - mode.eBands[j] * ( opus_int32 )mode.Fs / mode.shortMdctSize;
					allocVectors[i * mode.nbEBands + j] = ( a0 * band_allocation[i * maxBands + k - 1]
								+ a1 * band_allocation[i * maxBands + k] ) / ( a0 + a1 );
				}
			}
		}

		//printf ( "\n" );
		//for( i = 0; i < BITALLOC_SIZE; i++ )
		//{
		//	for( j = 0; j < mode.nbEBands; j++ )
		//	printf ( "%d ", allocVectors[i * mode.nbEBands + j] );
		//	printf ( "\n" );
		//}
		//exit( 0 );

		mode.allocVectors = allocVectors;
	}

#endif */ /* CUSTOM_MODES */

	static final JCELTMode opus_custom_mode_create(final int Fs, final int frame_size, final int[] error )
	{// FIXME opus_custom_mode_create returns CELTMode.
/* #ifdef CUSTOM_MODES
		JCELTMode  mode = null;
		int res;
		float[]    window;
		short[]    logN;
		int LM;
		int arch = opus_select_arch();
		ALLOC_STACK;
#if !defined( VAR_ARRAYS ) && !defined( USE_ALLOCA )
		if( global_stack == null )
			goto failure;
#endif
#endif */

// #ifndef CUSTOM_MODES_ONLY
		for( int i = 0; i < TOTAL_MODES; i++ )
		{
			for( int j = 0; j < 4; j++ )
			{
				final JCELTMode m = static_mode_list[i];// java
				if( Fs == m.Fs &&
					(frame_size << j) == m.shortMdctSize * m.nbShortMdcts )
				{
					if( null != error ) {
						error[0] = Jopus_defines.OPUS_OK;
					}
					return m;
				}
			}
		}
// #endif /* CUSTOM_MODES_ONLY */

// #ifndef CUSTOM_MODES
		if( null != error ) {
			error[0] = Jopus_defines.OPUS_BAD_ARG;
		}
		return null;
/* #else

		// The good thing here is that permutation of the arguments will automatically be invalid

		if( Fs < 8000 || Fs > 96000 )
		{
			if( error )
				* error = Jopus_defines.OPUS_BAD_ARG;
			return NULL;
		}
		if( frame_size < 40 || frame_size > 1024 || frame_size%2! = 0 )
		{
			if( error )
				* error = Jopus_defines.OPUS_BAD_ARG;
			return NULL;
		}
		// Frames of less than 1ms are not supported.
		if( ( opus_int32 )frame_size * 1000 < Fs )
		{
			if( error )
				* error = Jopus_defines.OPUS_BAD_ARG;
			return NULL;
		}

		if( ( opus_int32 )frame_size * 75 >= Fs && ( frame_size%16 ) == 0 )
		{
			LM = 3;
		} else if( ( opus_int32 )frame_size * 150 >= Fs && ( frame_size%8 ) == 0 )
		{
			LM = 2;
		} else if( ( opus_int32 )frame_size * 300 >= Fs && ( frame_size%4 ) == 0 )
		{
			LM = 1;
		} else
		{
			LM = 0;
		}

		// Shorts longer than 3.3ms are not supported.
		if( ( opus_int32 )( frame_size>>LM ) * 300 > Fs )
		{
			if( error )
				* error = Jopus_defines.OPUS_BAD_ARG;
			return NULL;
		}

		mode = opus_alloc( sizeof( CELTMode ) );
		if( mode == NULL )
			goto failure;
		mode.Fs = Fs;

		// Pre / de - emphasis depends on sampling rate. The "standard" pre - emphasis
		// is defined as A( z ) = 1 - 0.85 * z^ - 1 at 48 kHz. Other rates should
		// approximate that.
		if( Fs < 12000 ) // 8 kHz
		{
			mode.preemph[0] =  QCONST16( 0.3500061035f, 15 );
			mode.preemph[1] =  - QCONST16( 0.1799926758f, 15 );
			mode.preemph[2] =  QCONST16( 0.2719968125f, SIG_SHIFT );  // exact 1 / preemph[3]
			mode.preemph[3] =  QCONST16( 3.6765136719f, 13 );
		} else if( Fs < 24000 ) // 16 kHz
		{
			mode.preemph[0] =  QCONST16( 0.6000061035f, 15 );
			mode.preemph[1] =  - QCONST16( 0.1799926758f, 15 );
			mode.preemph[2] =  QCONST16( 0.4424998650f, SIG_SHIFT );  // exact 1 / preemph[3]
			mode.preemph[3] =  QCONST16( 2.2598876953f, 13 );
		} else if( Fs < 40000 ) // 32 kHz
		{
			mode.preemph[0] =  QCONST16( 0.7799987793f, 15 );
			mode.preemph[1] =  - QCONST16( 0.1000061035f, 15 );
			mode.preemph[2] =  QCONST16( 0.7499771125f, SIG_SHIFT );  // exact 1 / preemph[3]
			mode.preemph[3] =  QCONST16( 1.3333740234f, 13 );
		} else // 48 kHz
		{
			mode.preemph[0] =  QCONST16( 0.8500061035f, 15 );
			mode.preemph[1] =  QCONST16( 0.0f, 15 );
			mode.preemph[2] =  QCONST16( 1.f, SIG_SHIFT );
			mode.preemph[3] =  QCONST16( 1.f, 13 );
		}

		mode.maxLM = LM;
		mode.nbShortMdcts = 1 << LM;
		mode.shortMdctSize = frame_size / mode.nbShortMdcts;
		res = ( mode.Fs + mode.shortMdctSize ) / ( 2 * mode.shortMdctSize );

		mode.eBands = compute_ebands( Fs, mode.shortMdctSize, res, &mode.nbEBands );
		if( mode.eBands == NULL )
			goto failure;
#if !defined( SMALL_FOOTPRINT )
		// Make sure we don't allocate a band larger than our PVQ table.
		// 208 should be enough, but let's be paranoid.
		if( ( mode.eBands[mode.nbEBands] - mode.eBands[mode.nbEBands - 1] ) << LM > 208 ) {
			goto failure;
		}
#endif

		mode.effEBands = mode.nbEBands;
		while ( mode.eBands[mode.effEBands] > mode.shortMdctSize )
			mode.effEBands--;

		// Overlap must be divisible by 4
		mode.overlap = ( ( mode.shortMdctSize >> 2 ) << 2 );

		compute_allocation_table( mode );
		if( mode.allocVectors == NULL )
			goto failure;

		window = ( opus_val16 * )opus_alloc( mode.overlap * sizeof( opus_val16 ) );
		if( window == NULL )
			goto failure;

#ifndef FIXED_POINT
		for( i = 0; i < mode.overlap; i++ )
			window[i] = Q15ONE * sin( .5 * Math.PI * sin( .5 * Math.PI * (i + .5) / mode.overlap ) * sin( .5 * Math.PI * (i + .5) / mode.overlap ) );
#else
		for( i = 0; i < mode.overlap; i++ )
			window[i] = MIN32( 32767,floor( .5 + 32768. * sin( .5 * Math.PI * sin( .5 * Math.PI * (i + .5) / mode.overlap ) * sin( .5 * Math.PI * (i + .5) / mode.overlap ) ) ) );
#endif
		mode.window = window;

		logN = ( opus_int16 * )opus_alloc( mode.nbEBands * sizeof( opus_int16 ) );
		if( logN == NULL )
			goto failure;

		for( i = 0; i < mode.nbEBands; i++ )
			logN[i] = log2_frac( mode.eBands[i + 1] - mode.eBands[i], BITRES );
		mode.logN = logN;

		compute_pulse_cache( mode, mode.maxLM );

		if( clt_mdct_init( &mode.mdct, 2 * mode.shortMdctSize * mode.nbShortMdcts, mode.maxLM, arch ) == 0 )
			goto failure;

		if( error )
			* error = Jopus_defines.OPUS_OK;

		return mode;
	failure:
		if( error )
			* error = Jopus_defines.OPUS_ALLOC_FAIL;
		if( mode! = NULL )
			opus_custom_mode_destroy( mode );
		return NULL;
#endif */ /* !CUSTOM_MODES */
	}

/* #ifdef CUSTOM_MODES
	private static final void opus_custom_mode_destroy(JCELTMode mode )
	{
		int arch = opus_select_arch();

		if( mode == NULL )
			return;
#ifndef CUSTOM_MODES_ONLY
		{
			int i;
			for( i = 0; i < TOTAL_MODES; i++ )
			{
				if( mode == static_mode_list[i] )
				{
					return;
				}
			}
		}
#endif // CUSTOM_MODES_ONLY
		opus_free( ( opus_int16 * )mode.eBands );
		opus_free( ( unsigned char * )mode.allocVectors );

		opus_free( ( opus_val16 * )mode.window );
		opus_free( ( opus_int16 * )mode.logN );

		opus_free( ( opus_int16 * )mode.cache.index );
		opus_free( ( unsigned char * )mode.cache.bits );
		opus_free( ( unsigned char * )mode.cache.caps );
		clt_mdct_clear( &mode.mdct, arch );

		opus_free( ( CELTMode * )mode );
	}
#endif */

	// start celt.c
	final void init_caps(final int[] cap, final int LM, final int C)
	{
		final short bands[] = this.eBands;// java
		final char[] caps = this.cache.caps;// java
		for( int i = 0, n = this.nbEBands; i < n; i++ )
		{
			final int N = (bands[i + 1] - bands[i]) << LM;
			cap[i] = (caps[n * ((LM << 1) + C - 1) + i] + 64) * C * N >> 2;
		}
	}
	// end celt.c

	// start bands.h
	// bands.h
	static final int SPREAD_NONE       = 0;
	private static final int SPREAD_LIGHT      = 1;
	static final int SPREAD_NORMAL     = 2;
	static final int SPREAD_AGGRESSIVE = 3;
	// end bands.h

	// start bands.c
// #ifdef FIXED_POINT
	/** Compute the amplitude ( sqrt energy ) in each of the bands */
/*	void compute_band_energies(final CELTMode *m, const celt_sig *X, celt_ener *bandE, int end, int C, int LM, int arch )
	{
		int i, c, N;
		const opus_int16 *eBands = m.eBands;
		(void)arch;
		N = m.shortMdctSize << LM;
		c = 0;
		do {
			for( i = 0; i < end; i++ )
			{
				int j;
				opus_val32 maxval = 0;
				opus_val32 sum = 0;

				maxval = celt_maxabs32( &X[c * N + (eBands[i] << LM)], (eBands[i + 1] - eBands[i]) << LM );
				if( maxval > 0 )
				{
					int shift = celt_ilog2( maxval ) - 14 + (((m.logN[i] >> BITRES) + LM + 1) >> 1);
					j = eBands[i] << LM;
					if( shift > 0 )
					{
						do {
							sum = MAC16_16( sum, EXTRACT16( SHR32( X[j + c * N],shift ) ),
									EXTRACT16( SHR32( X[j + c * N],shift ) ) );
						} while( ++j < eBands[i + 1] << LM );
					} else {
						do {
							sum = MAC16_16( sum, EXTRACT16( SHL32( X[j + c * N], - shift ) ),
									EXTRACT16( SHL32( X[j + c * N], - shift ) ) );
						} while ( ++j < eBands[i + 1] << LM );
					}
					// We're adding one here to ensure the normalized band isn't larger than unity norm
					bandE[i + c * m.nbEBands] = EPSILON + VSHR32( EXTEND32( celt_sqrt( sum ) ), -shift );
				} else {
					bandE[i + c * m.nbEBands] = EPSILON;
				}
				//printf ( "%f ", bandE[i + c*m.nbEBands] );
			}
		} while( ++c < C );
		//printf( "\n" );
	}
*/
	/** Normalise each band such that the energy is one. */
/*	void normalise_bands( const CELTMode *m, const celt_sig * OPUS_RESTRICT freq, celt_norm * OPUS_RESTRICT X, const celt_ener *bandE, int end, int C, int M )
	{
		int i, c, N;
		const opus_int16 *eBands = m.eBands;
		N = M * m.shortMdctSize;
		c = 0;
		do {
			i = 0;
			do {
				opus_val16 g;
				int j,shift;
				opus_val16 E;
				shift = celt_zlog2( bandE[i + c * m.nbEBands] ) - 13;
				E = VSHR32( bandE[i + c * m.nbEBands], shift );
				g = EXTRACT16( celt_rcp( SHL32( E,3 ) ) );
				j = M * eBands[i];
				do {
					X[j + c * N] = MULT16_16_Q15( VSHR32( freq[j + c * N],shift - 1 ), g );
				} while ( ++j < M * eBands[i + 1] );
			} while ( ++i < end );
		} while ( ++c < C );
	}
*/
// #else /* FIXED_POINT */

	/** Compute the amplitude (sqrt energy) in each of the bands
	 * @param m Mode data
	 * @param X Spectrum
	 * @param bandE Square root of the energy for each band (returned)
	 */
	public final void compute_band_energies(final float[] X, final float[] bandE, final int end, int C, final int LM )// int arch )
	{
		final short[] bands = this.eBands;
		final int N = this.shortMdctSize << LM;
		C *= this.nbEBands;// java
		int c = 0;
		int cN = 0;// java
		do {
			for( int i = 0; i < end; i++ )
			{
				final int offset = cN + (bands[i] << LM);// java
				final float sum = 1e-27f + celt_inner_prod( X, offset, X, offset, (bands[i + 1] - bands[i]) << LM );// arch
				bandE[i + c] = (float)Math.sqrt( (double)sum );
				/*printf ( "%f ", bandE[i + c*m.nbEBands] ); */
			}
			cN += N;// java
			c += this.nbEBands;// java
		} while ( c < C );
		/*printf ( "\n" ); */
	}

	/** Normalise each band of X such that the energy in each band is
	 * equal to 1
	 * @param m Mode data
	 * @param X Spectrum (returned normalised)
	 * @param bandE Square root of the energy for each band
	 */
	final void normalise_bands(final float[] freq, final float[] X, final float[] bandE, final int end, int C, final int M )
	{
		final short[] bands = this.eBands;
		final int N = M * this.shortMdctSize;
		C *= this.nbEBands;// java
		int c = 0;
		int cN = 0;// java
		do {
			for( int i = 0; i < end; i++ )
			{
				final float g = 1.f / (1e-27f + bandE[i + c]);
				for( int j = M * bands[i] + cN, jend = M * bands[i + 1] + cN; j < jend; j++ ) {
					X[j] = freq[j] * g;
				}
			}
			cN += N;// java
			c += this.nbEBands;// java
		} while( c < C );
	}

// #endif /* FIXED_POINT */

	/** De - normalise the energy to produce the synthesis from the unit - energy bands */
	/** Denormalise each band of X to restore full amplitude
	 * @param m Mode data
	 * @param X Spectrum (returned de-normalised)
	 * @param bandE Square root of the energy for each band
	 */
	private final void denormalise_bands(
			final float[] X, final int xoffset,
			final float[] freq, final int foffset,
			final float[] bandLogE, int boffset,
			int start,
			int end, final int M, final int downsample, final boolean silence)
	{
		final short[] bands = this.eBands;
		int N = M * this.shortMdctSize;
		int bound = M * bands[end];
		if( downsample != 1 ) {
			final int v = N / downsample;
			bound = bound <= v ? bound : v;
		}
		if( silence )
		{
			bound = 0;
			start = end = 0;
		}
		int f = foffset;// freq[f]
		int x = M * bands[start];// java X[x]
		for( final int fe = x + f; f < fe; f++ ) {
			freq[f] = 0;
		}
		x += xoffset;// java
		boffset += start;// java
		for( int i = start; i < end; i++ )
		{
/* #ifdef FIXED_POINT
			int shift;
#endif */
			int j = M * bands[i];
			final int band_end = M * bands[i + 1];
			final float lg = bandLogE[boffset++] + eMeans[i];
// #ifndef FIXED_POINT
			final float g = ((float)Math.exp( (32f < lg ? (32. * 0.6931471805599453094) : (double)lg * 0.6931471805599453094) ));
/* #else
			// Handle the integer part of the log energy
			shift = 16 - (lg >> DB_SHIFT);
			if( shift > 31 )
			{
				shift = 0;
				g = 0;
			} else {
				// Handle the fractional part.
				g = Jmathops.celt_exp2_frac( lg & ((1 << DB_SHIFT) - 1) );
			}
			// Handle extreme gains with negative shift.
			if( shift < 0 )
			{
				// For shift <= -2 and g > 16384 we'd be likely to overflow, so we're
				// capping the gain here, which is equivalent to a cap of 18 on lg.
				// This shouldn't trigger unless the bitstream is already corrupted.
				if( shift <= -2 )
				{
					g = 16384;
					shift = -2;
				}
				do {
					*f++ = SHL32( MULT16_16( *x++, g ), -shift );
				} while ( ++j < band_end );
			} else
#endif */
			/* Be careful of the fixed - point "else" just above when changing this code */
			do {
				freq[f++] = X[x++] * g;
			} while( ++j < band_end );
		}
		// celt_assert( start <= end );
		// OPUS_CLEAR( &freq[bound], N - bound );
		N += foffset;
		for( f = foffset + bound; f < N; f++ ) {
			freq[f] = 0f;
		}
	}

	/** This prevents energy collapse for transients with multiple short MDCTs */
	final void anti_collapse(final float[] X_, final byte[] collapse_masks,
			final int LM, final int C, final int size, final int start, final int end,
			final float[] logE, final float[] prev1logE, final float[] prev2logE,
			final int[] pulses, int seed)//, final int arch )
	{
		for( int i = start; i < end; i++ )
		{
/* #ifdef FIXED_POINT
			int shift;
			opus_val32 thresh32;
#endif */

			final int N0 = this.eBands[i + 1] - this.eBands[i];
			final int n0_lm = N0 << LM;// java
			final int lmp2 = 1 << LM;// java
			/* depth in 1/8 bits */
			//celt_sig_assert( pulses[i] >= 0 );
			final int depth = ((1 + pulses[i]) / (this.eBands[i + 1] - this.eBands[i])) >> LM;

/* #ifdef FIXED_POINT
			thresh32 = SHR32( celt_exp2(  - SHL16( depth, 10 - BITRES ) ),1 );
			thresh = MULT16_32_Q15( QCONST16( 0.5f, 15 ), MIN32( 32767,thresh32 ) );
			{
				opus_val32 t;
				t = N0 << LM;
				shift = celt_ilog2( t ) >> 1;
				t = SHL32( t, ( 7 - shift ) << 1 );
				sqrt_1 = celt_rsqrt_norm( t );
			}
#else */
			final float thresh = .5f * ((float)Math.exp( 0.6931471805599453094 * (-.125f * depth)));// celt_exp2( -.125f * depth );
			final float sqrt_1 = 1f / (float)Math.sqrt( (double)n0_lm );// celt_rsqrt( N0 << LM );
//#endif

			int c = 0;
			do
			{
				boolean renormalize = false;
				int offset = c * this.nbEBands + i;// java
				float prev1 = prev1logE[offset];
				float prev2 = prev2logE[offset];
				if( C == 1 )
				{
					final int s = this.nbEBands + i;// java
					float v = prev1logE[s];// java
					prev1 = prev1 >= v ? prev1 : v;
					v = prev2logE[s];
					prev2 = prev2 >= v ? prev2 : v;
				}
				float Ediff = logE[offset] - (prev1 <= prev2 ? prev1 : prev2);
				Ediff = 0 >= Ediff ? 0 : Ediff;

/* #ifdef FIXED_POINT
				if( Ediff < 16384 )
				{
				opus_val32 r32 = SHR32( celt_exp2(  - EXTRACT16( Ediff ) ),1 );
				r = 2*MIN16( 16383,r32 );
				} else {
				r = 0;
				}
				if( LM == 3 )
					r = MULT16_16_Q14( 23170, MIN32( 23169, r ) );
				r = SHR16( MIN16( thresh, r ),1 );
				r = SHR32( MULT16_16_Q15( sqrt_1, r ),shift );
#else */
				/* r needs to be multiplied by 2 or 2*sqrt( 2 ) depending on LM because
				   short blocks don't have the same energy as long */
				float r = 2.f * ((float)Math.exp( 0.6931471805599453094 * (-Ediff) ));// celt_exp2( -Ediff );
				if( LM == 3 ) {
					r *= 1.41421356f;
				}
				r = thresh <= r ? thresh : r;
				r *= sqrt_1;
// #endif
				final int X = c * size + (this.eBands[i] << LM);// X_[X]
				offset = (int)collapse_masks[i * C + c];// java
				for( int k = 0; k < lmp2/*1 << LM*/; k++ )
				{
					/* Detect collapse */
					if( 0 == (offset & 1 << k) )
					{
						final int xk = X + k;// java
						/* Fill with noise */
						for( int j = 0; j < N0; j++ )
						{
							seed = Jband_ctx.celt_lcg_rand( seed );
							X_[xk + (j << LM)] = ((seed & 0x8000) != 0 ? r : -r);
						}
						renormalize = true;
					}
				}
				/* We just added some energy, so we need to renormalise */
				if( renormalize ) {
					Jband_ctx.renormalise_vector( X_, X, n0_lm, Jfloat_cast.Q15ONE );//, arch );
				}
			} while ( ++c < C );
		}
	}

	/** Decide whether we should spread the pulses in the current frame
	 *
	 * <p>java changed: added JCELTEncoder enc to get and return data.
	 * <pre>
	 * average -> st.tonal_average
	 * last_decision -> st.spread_decision
	 * hf_average -> st.hf_average
	 * tapset_decision -> st.tapset_decision
	 * decision -> st.spread_decision
	 * </pre>
	 *
	 * @param m
	 * @param X
	 * @param average
	 * @param last_decision
	 * @param hf_average
	 * @param tapset_decision
	 * @param update_hf
	 * @param end
	 * @param C
	 * @param M
	 * @param spread_wight
	 * @return st.spread_decision, st.tonal_average, st.hf_average, st.tapset_decision
	 */
	final void spreading_decision(final JCELTEncoder enc,// java
			final float[] X,
			// final int[] average, final int last_decision, final int[] hf_average, final int[] tapset_decision,
			final boolean update_hf,
			final int end, final int C, final int M, final int[] spread_weight)
	{
		int sum = 0, nbBands = 0;
		final short[] bands = this.eBands;
		int hf_sum = 0;

		//celt_assert( end > 0 );

		final int N0 = M * this.shortMdctSize;

		if( M * (bands[end] - bands[end - 1]) <= 8 ) {
			// return SPREAD_NONE;// java
			enc.spread_decision = SPREAD_NONE;
			return;// java
		}
		int c = 0;
		do {
			for( int i = 0; i < end; i++ )
			{
				final int tcount[/* 3 */] = { 0, 0, 0 };
				int x = M * bands[i] + c * N0;// X[x]
				final int N = M * (bands[i + 1] - bands[i]);
				if( N <= 8 ) {
					continue;
				}
				/* Compute rough CDF of |x[j]| */
				for( final int j = x + N; x < j; x++ )
				{
					float x2N = X[x];  /* Q13 */
					x2N *= x2N;
					x2N *= N;
					if( x2N < 0.25f ) {
						tcount[0]++;
					}
					if( x2N < 0.0625f ) {
						tcount[1]++;
					}
					if( x2N < 0.015625f ) {
						tcount[2]++;
					}
				}

				/* Only include four last bands ( 8 kHz and up ) */
				if( i > this.nbEBands - 4 ) {
					hf_sum += ((tcount[1] + tcount[0]) << 5) / N;
				}
				final int tmp = ((tcount[2] << 1) >= N ? 1 : 0) + ((tcount[1] << 1) >= N ? 1 : 0) + ((tcount[0] << 1) >= N ? 1 : 0);
				x = spread_weight[ i ];// java
				sum += tmp * x;// java tmp * spread_weight[ i ];
				nbBands += x;// java spread_weight[ i ];
			}
		} while( ++c < C );

		if( update_hf )
		{
			if( 0 != hf_sum ) {
				hf_sum = hf_sum / (C * (4 - this.nbEBands + end));
			}
			enc.hf_average = (enc.hf_average + hf_sum) >> 1;
			hf_sum = enc.hf_average;
			if( enc.tapset_decision == 2 ) {
				hf_sum += 4;
			} else if( enc.tapset_decision == 0 ) {
				hf_sum -= 4;
			}
			if( hf_sum > 22 ) {
				enc.tapset_decision = 2;
			} else if( hf_sum > 18 ) {
				enc.tapset_decision = 1;
			} else {
				enc.tapset_decision = 0;
			}
		}
		/*printf( "%d %d %d\n", hf_sum, *hf_average, *tapset_decision ); */
		// celt_assert( nbBands > 0 );  /* end has to be non - zero */
		// celt_assert( sum >= 0 );
		sum <<= 8;
		sum /= nbBands;// FIXME why celt_udiv?
		/* Recursive averaging */
		sum = (sum + enc.tonal_average) >> 1;
		enc.tonal_average = sum;
		/* Hysteresis */
		sum = (3 * sum + (((3 - enc.spread_decision) << 7) + 64) + 2) >> 2;
		int decision;
		if( sum < 80 )
		{
			decision = SPREAD_AGGRESSIVE;
		} else if( sum < 256 )
		{
			decision = SPREAD_NORMAL;
		} else if( sum < 384 )
		{
			decision = SPREAD_LIGHT;
		} else {
			decision = SPREAD_NONE;
		}
/* #ifdef FUZZING
		decision = rand() & 0x3;
		*tapset_decision = rand() % 3;
#endif */
		// return decision;// java
		enc.spread_decision = decision;// java
	}

	/* Compute the weights to use for optimizing normalized distortion across
	   channels. We use the amplitude to weight square distortion, which means
	   that we use the square root of the value we would have been using if we
	   wanted to minimize the MSE in the non-normalized domain. This roughly
	   corresponds to some quick-and-dirty perceptual experiments I ran to
	   measure inter-aural masking (there doesn't seem to be any published data
	   on the topic). */
	private static final void compute_channel_weights(float Ex, float Ey, final float w[/* 2 */])
	{
/* #if FIXED_POINT
		int shift;
#endif */
		final float minE = ( Ex < Ey ? Ex : Ey ) / 3.f;// java: added /3
		/* Adjustment to make the weights a bit more conservative. */
		Ex = (Ex + minE);// java changed Ex = (Ex + minE / 3);
		Ey = (Ey + minE);// java changed Ey = (Ey + minE / 3);
/* #if FIXED_POINT
		shift = celt_ilog2(EPSILON+MAX32(Ex, Ey))-14;
#endif */
		w[0] = Ex;
		w[1] = Ey;
	}

	private final void special_hybrid_folding(final float[] norm, final int noffset, final float[] norm2, final int noffset2, int start, final int M, final boolean dual_stereo)
	{
		final short[] bands = this.eBands;
		final int n1 = M * (bands[start + 1] - bands[start]);
		int n2 = M * (bands[start + 2] - bands[start + 1]);
		/* Duplicate enough of the first band folding data to be able to fold the second band.
		  Copies no data for CELT-only mode. */
		start = (n1 << 1) - n2;// java
		n2 -= n1;// java
		System.arraycopy( norm, noffset + start, norm, noffset + n1, n2 );
		if( dual_stereo ) {
			System.arraycopy( norm2, noffset2 + start, norm2, noffset2 + n1, n2 );
		}
	}

	/** Quantisation/encoding of the residual spectrum
	 *
	 * java changed: return new value of the seed
	 *
	 * @param encode flag that indicates whether we're encoding (1) or decoding (0)
	 * @param m Mode data
	 * @param start First band to process
	 * @param end Last band to process + 1
	 * @param X_ Residual (normalised)
	 * @param Y_ Residual (normalised) for second channel (or NULL for mono)
	 * @param yoffset java an offset for the Y
	 * @param collapse_masks Anti-collapse tracking mask
	 * @param bandE Square root of the energy for each band
	 * @param pulses Bit allocation (per band) for PVQ
	 * @param shortBlocks Zero for long blocks, non-zero for short blocks
	 * @param spread Amount of spreading to use
	 * @param dual_stereo Zero for MS stereo, non-zero for dual stereo
	 * @param intensity First band to use intensity stereo
	 * @param tf_res Time-frequency resolution change
	 * @param total_bits Total number of bits that can be used for the frame (including the ones already spent)
	 * @param balance Number of unallocated bits
	 * @param ec Entropy coder state
	 * @param LM log2() of the number of 2.5 subframes in the frame
	 * @param codedBands Last band to receive bits + 1
	 * @param seed Random generator seed
	 * @param complexity
	 * @param arch Run-time architecture (see opus_select_arch())
	 * @param disable_inv
	 * @return new value of the seed
	 */
	final int quant_all_bands(final boolean encode, final int start, final int end,
				final float[] X_,
				final float[] Y_, final int yoffset,// java
				final byte[] collapse_masks,
				final float[] bandE, final int[] pulses, final int shortBlocks, final int spread,
				boolean dual_stereo, final int intensity, final int[] tf_res, final int total_bits,
				int balance, final Jec_ctx ec, final int LM, final int codedBands, final int seed,
				final int complexity,/* int arch, */ final boolean disable_inv )
	{
		final short[] bands = this.eBands;// java renamed to avoid hiding
		boolean update_lowband = true;
		final int C = Y_ != null ? 2 : 1;
		final boolean theta_rdo = encode && Y_ != null && ! dual_stereo && complexity >= 8;
/* #ifdef RESYNTH
		int resynth = 1;
#else */
		final boolean resynth = ! encode || theta_rdo;
//#endif
		final Jband_ctx ctx = new Jband_ctx();
		//SAVE_STACK;

		final int M = 1 << LM;
		final int B = shortBlocks != 0 ? M : 1;
		final int norm_offset = M * bands[start];
		int lowband_scratch = M * bands[this.nbEBands - 1];// X_[lowband_scratch]
		/* No need to allocate norm for the last band because we don't need an
		   output in that band. */
		final float[] _norm = new float[C * (lowband_scratch - norm_offset)];
		final int norm = 0;// _norm[norm] FIXME why need norm?
		final int norm2 = norm + lowband_scratch - norm_offset;// _norm[norm2]

		int resynth_alloc = 0;// java
		/* For decoding, we can use the last band as scratch space because we don't need that
		  scratch space for the last band and we don't care about the data there until we're
		  decoding the last band. */
		if( encode && resynth ) {
			resynth_alloc = M * (bands[this.nbEBands] - bands[this.nbEBands - 1]);
		}
		//else
		//	resynth_alloc = 0;// ALLOC_NONE;

		float[] scratch_dim;// java scratch_dim[lowband_scratch]. added to avoid changing a code in other methods
		final float[] _lowband_scratch = new float[resynth_alloc];
		if( encode && resynth ) {
			lowband_scratch = 0;// _lowband_scratch;
			scratch_dim = _lowband_scratch;// _lowband_scratch[lowband_scratch]
		} else {
			// lowband_scratch = M * bands[this.nbEBands - 1];// X_[lowband_scratch]
			scratch_dim = X_;
		}

		final float[] X_save = new float[resynth_alloc];
		final float[] Y_save = new float[resynth_alloc];
		final float[] X_save2 = new float[resynth_alloc];
		final float[] Y_save2 = new float[resynth_alloc];
		final float[] norm_save2 = new float[resynth_alloc];

		int lowband_offset = 0;
		ctx.bandE = bandE;
		ctx.ec = ec;
		ctx.encode = encode;
		ctx.intensity = intensity;
		ctx.m = this;
		ctx.seed = seed;
		ctx.spread = spread;
		// ctx.arch = arch;
		ctx.disable_inv = disable_inv;
		ctx.resynth = resynth;
		ctx.theta_round = 0;
		/* Avoid injecting noise in the first band on transients. */
		ctx.avoid_split_noise = B > 1;
		for( int i = start; i < end; i++ )
		{
			ctx.i = i;

			int m_bands_i = M * bands[i];// java
			int X = m_bands_i;// X_[X]
			int Y;// Y_[Y]
			float[] xdim = X_;// java to use together with X. xdim[X]
			float[] ydim = Y_;// java to use together with Y. ydim[Y]
			if( Y_ != null ) {
				Y = yoffset + m_bands_i;
			} else {
				Y = -1;// null
			}
			final int N = M * bands[i + 1] - m_bands_i;
			// celt_assert(N > 0);
			final int tell = ec.ec_tell_frac();

			/* Compute how many bits we want to allocate to this band */
			if( i != start ) {
				balance -= tell;
			}
			int b = total_bits - tell - 1;// java final int remaining_bits = total_bits - tell - 1;
			ctx.remaining_bits = b;// java remaining_bits;
			if( i <= codedBands - 1 )
			{
				// curr_balance = celt_sudiv(balance, IMIN(3, codedBands-i));
				// b = IMAX(0, IMIN(16383, IMIN(remaining_bits+1,pulses[i]+curr_balance)));
				int curr_balance = codedBands - i;// java
				if( curr_balance > 3 ) {
					curr_balance = 3;
				}
				curr_balance = balance / curr_balance;
				b++;// java = remaining_bits + 1
				curr_balance += pulses[i];// java
				if( b > curr_balance ) {
					b = curr_balance;
				}
				b = 16383 <= b ? 16383 : (0 >= b ? 0 : b);
			} else {
				b = 0;
			}

if( ! Jopus_defines.DISABLE_UPDATE_DRAFT ) {
			if( resynth && (M * eBands[i] - N >= M * eBands[start] || i == start + 1) && (update_lowband || lowband_offset == 0) ) {
				lowband_offset = i;
			}
			if( i == start + 1 ) {
				special_hybrid_folding( _norm, norm, _norm, norm2, start, M, dual_stereo );
			}
} else {
			if( resynth && m_bands_i - N >= M * bands[start] && (update_lowband || lowband_offset == 0) ) {
				lowband_offset = i;
			}
}

			final int tf_change = tf_res[i];
			ctx.tf_change = tf_change;
			if( i >= this.effEBands )
			{
				X = norm;// _norm[ X ]
				xdim = _norm;// java
				if( Y_ != null ) {
					Y = norm;// _norm[ Y ]
					ydim = _norm;// java
				}
				scratch_dim = null;// lowband_scratch = NULL;
			}
			final boolean last = (i == end - 1);
			if( last && ! theta_rdo ) {
				scratch_dim = null;// lowband_scratch = NULL;
			}

			/* Get a conservative estimate of the collapse_mask's for the bands we're
			   going to be folding from. */
			int effective_lowband = -1;
			int x_cm, y_cm;
			if( lowband_offset != 0 && (spread != SPREAD_AGGRESSIVE || B > 1 || tf_change < 0) )
			{
				/* This ensures we never repeat spectral content within one band */
				effective_lowband = M * bands[lowband_offset] - norm_offset - N;
				effective_lowband = 0 >= effective_lowband ? 0 : effective_lowband;
				int fold_start = lowband_offset;
				while( M * bands[--fold_start] > effective_lowband + norm_offset ) {
					;
				}
				int fold_end = lowband_offset - 1;
if( ! Jopus_defines.DISABLE_UPDATE_DRAFT ) {
				while( ++fold_end < i && M * eBands[fold_end] < effective_lowband + norm_offset + N) {
					;
				}
} else {
				while( M * bands[++fold_end] < effective_lowband + norm_offset + N ) {
					;
				}
}
				x_cm = y_cm = 0;
				int fold_i = fold_start;
				do {
					final int v = fold_i * C;// java
					x_cm |= (int)collapse_masks[v] & 0xff;
					y_cm |= (int)collapse_masks[v + C - 1] & 0xff;
				} while( ++fold_i < fold_end );
			}
			/* Otherwise, we'll be using the LCG to fold, so all blocks will ( almost
			   always ) be non - zero. */
			else {
				x_cm = y_cm = (1 << B) - 1;
			}

			m_bands_i -= norm_offset;// java
			if( dual_stereo && i == intensity )
			{
				/* Switch off dual stereo to do intensity. */
				dual_stereo = false;
				if( resynth ) {
					for( int j = norm, count = norm + m_bands_i, j2 = norm2; j < count; j++, j2++ ) {
						_norm[j] = 0.5f * (_norm[j] + _norm[j2]);
					}
				}
			}
			if( dual_stereo )
			{
				x_cm = ctx.quant_band( xdim, X, N, b >> 1, B,
						effective_lowband != -1 ? _norm : null, norm + effective_lowband, LM,
								last ? null : _norm, norm + m_bands_i, Jfloat_cast.Q15ONE, scratch_dim, lowband_scratch, x_cm );
				y_cm = ctx.quant_band( ydim, Y, N, b >> 1, B,
						effective_lowband != -1 ? _norm : null, norm2 + effective_lowband, LM,
								last ? null : _norm, norm2 + m_bands_i, Jfloat_cast.Q15ONE, scratch_dim, lowband_scratch, y_cm );
			} else {
				if( Y_ != null )
				{
					if( theta_rdo && i < intensity )
					{
						final byte bytes_save[] = new byte[1275];
						final float w[] = new float[2];
						compute_channel_weights( bandE[i], bandE[i + this.nbEBands], w );
						/* Make a copy. */
						final int cm = x_cm | y_cm;
						final Jec_ctx ec_save = new Jec_ctx( ec );
						final Jband_ctx ctx_save = new Jband_ctx( ctx );
						System.arraycopy( xdim, X, X_save, 0, N );
						System.arraycopy( ydim, Y, Y_save, 0, N );
						/* Encode and round down. */
						ctx.theta_round = -1;
						x_cm = ctx.quant_band_stereo( xdim, X, ydim, Y, N, b, B,
								effective_lowband != -1 ? _norm : null, norm + effective_lowband, LM,
								last ? null : _norm, norm + m_bands_i, scratch_dim, lowband_scratch, cm );
						final float dist0 = (w[0] * celt_inner_prod( X_save, 0, xdim, X, N/*, arch*/ )) + (w[1] * celt_inner_prod(Y_save, 0, ydim, Y, N/*, arch*/));

						/* Save first result. */
						final int cm2 = x_cm;
						final Jec_ctx ec_save2 = new Jec_ctx( ec );
						final Jband_ctx ctx_save2 = new Jband_ctx( ctx );
						System.arraycopy( xdim, X, X_save2, 0, N );
						System.arraycopy( ydim, Y, Y_save2, 0, N );
						if( ! last ) {
							System.arraycopy( _norm, norm + m_bands_i, norm_save2, 0, N );
						}
						final int nstart_bytes = ec_save.offs;
						final int nend_bytes = ec_save.storage;
						final int bytes_buf = ec_save.buf_start + nstart_bytes;// java ec_save.buf[ bytes_buf ]
						final int save_bytes = nend_bytes - nstart_bytes;
						System.arraycopy( ec_save.buf, bytes_buf, bytes_save, 0, save_bytes );

						/* Restore */
						ec.copyFrom( ec_save );
						ctx.copyFrom( ctx_save );
						System.arraycopy( X_save, 0, xdim, X, N );
						System.arraycopy( Y_save, 0, ydim, Y, N );
if( ! Jopus_defines.DISABLE_UPDATE_DRAFT ) {
						if( i == start + 1 ) {
							special_hybrid_folding( _norm, norm, _norm, norm2, start, M, dual_stereo );
						}
}
						/* Encode and round up. */
						ctx.theta_round = 1;
						x_cm = ctx.quant_band_stereo( xdim, X, xdim, Y, N, b, B,
								effective_lowband != -1 ? _norm : null, norm + effective_lowband, LM,
								last ? null : _norm, norm + m_bands_i, scratch_dim, lowband_scratch, cm);
						final float dist1 = (w[0] * celt_inner_prod( X_save, 0, xdim, X, N/*, arch*/ )) + (w[1] * celt_inner_prod( Y_save, 0, ydim, Y, N/*, arch*/ ));
						if( dist0 >= dist1 ) {
							x_cm = cm2;
							ec.copyFrom( ec_save2 );
							ctx.copyFrom( ctx_save2 );
							System.arraycopy( X_save2, 0, xdim, X, N );
							System.arraycopy( Y_save2, 0, ydim, Y, N );
							if( ! last ) {
								System.arraycopy( norm_save2, 0, _norm, norm + m_bands_i, N );
							}
							System.arraycopy( bytes_save, 0, ec_save.buf, bytes_buf, save_bytes );
						}
					} else {
						ctx.theta_round = 0;
						x_cm = ctx.quant_band_stereo( xdim, X, ydim, Y, N, b, B,
								effective_lowband != -1 ? _norm : null, norm + effective_lowband, LM,
								last ? null : _norm, norm + m_bands_i, scratch_dim, lowband_scratch, x_cm | y_cm);
					}
				} else {
					x_cm = ctx.quant_band( xdim, X, N, b, B,
							effective_lowband != -1 ? _norm : null, norm + effective_lowband, LM,
									last ? null : _norm, norm + m_bands_i, Jfloat_cast.Q15ONE, scratch_dim, lowband_scratch, x_cm | y_cm );
				}
				y_cm = x_cm;
			}
			int ic = i * C;// java
			collapse_masks[ic--] = (byte)x_cm;
			collapse_masks[ic + C] = (byte)y_cm;
			balance += pulses[i] + tell;

			/* Update the folding position only as long as we have 1 bit/sample depth. */
			update_lowband = b > (N << Jec_ctx.BITRES);
			/* We only need to avoid noise on a split for the first band. After that, we
			cchave folding. */
			ctx.avoid_split_noise = false;
		}
		return ctx.seed;// java seed[0] = ctx.seed;

		//RESTORE_STACK;
	}
	// end bands.c

	// start quant_bands.c
// #ifdef FIXED_POINT
	/** Mean energy in each band quantized in Q4 */
/*	const signed char eMeans[25] = {
		103,100, 92, 85, 81,
		77, 72, 70, 78, 75,
		73, 71, 78, 74, 69,
		72, 70, 74, 76, 71,
		60, 60, 60, 60, 60
	}; */
// #else
	/** Mean energy in each band quantized in Q4 and converted back to float */
	static final float eMeans[/* 25 */] = {
		6.437500f, 6.250000f, 5.750000f, 5.312500f, 5.062500f,
		4.812500f, 4.500000f, 4.375000f, 4.875000f, 4.687500f,
		4.562500f, 4.437500f, 4.875000f, 4.625000f, 4.312500f,
		4.500000f, 4.375000f, 4.625000f, 4.750000f, 4.437500f,
		3.750000f, 3.750000f, 3.750000f, 3.750000f, 3.750000f
	};
// #endif
/* prediction coefficients: 0.9, 0.8, 0.65, 0.5 */
/* #ifdef FIXED_POINT
	static const opus_val16 pred_coef[4] = {29440, 26112, 21248, 16384};
	static const opus_val16 beta_coef[4] = {30147, 22282, 12124, 6554};
	static const opus_val16 beta_intra = 4915;
#else */
	private static final float pred_coef[/* 4 */] = { 29440f / 32768.f, 26112f / 32768.f, 21248f / 32768.f, 16384f / 32768.f };
	private static final float beta_coef[/* 4 */] = { 30147f / 32768.f, 22282f / 32768.f, 12124f / 32768.f, 6554f / 32768.f };
	private static final float beta_intra = 4915f / 32768.f;
// #endif

	/** Parameters of the Laplace-like probability models used for the coarse energy.
	There is one pair of parameters for each frame size, prediction type
	(inter/intra), and band number.
	The first number of each pair is the probability of 0, and the second is the
	decay rate, both in Q8 precision. */
	private static final char e_prob_model[/* 4 */][/* 2 */][/* 42 */] = {// java uint8 to char
		/*120 sample frames.*/
		{
			/*Inter*/
			{
				72, 127,  65, 129,  66, 128,  65, 128,  64, 128,  62, 128,  64, 128,
				64, 128,  92,  78,  92,  79,  92,  78,  90,  79, 116,  41, 115,  40,
				114,  40, 132,  26, 132,  26, 145,  17, 161,  12, 176,  10, 177,  11
			},
			/*Intra*/
			{
				24, 179,  48, 138,  54, 135,  54, 132,  53, 134,  56, 133,  55, 132,
				55, 132,  61, 114,  70,  96,  74,  88,  75,  88,  87,  74,  89,  66,
				91,  67, 100,  59, 108,  50, 120,  40, 122,  37,  97,  43,  78,  50
			}
		},
		/*240 sample frames.*/
		{
			/*Inter*/
			{
				83,  78,  84,  81,  88,  75,  86,  74,  87,  71,  90,  73,  93,  74,
				93,  74, 109,  40, 114,  36, 117,  34, 117,  34, 143,  17, 145,  18,
				146,  19, 162,  12, 165,  10, 178,   7, 189,   6, 190,   8, 177,   9
			},
			/*Intra*/
			{
				23, 178,  54, 115,  63, 102,  66,  98,  69,  99,  74,  89,  71,  91,
				73,  91,  78,  89,  86,  80,  92,  66,  93,  64, 102,  59, 103,  60,
				104,  60, 117,  52, 123,  44, 138,  35, 133,  31,  97,  38,  77,  45
			}
		},
		/*480 sample frames.*/
		{
			/*Inter*/
			{
				61,  90,  93,  60, 105,  42, 107,  41, 110,  45, 116,  38, 113,  38,
				112,  38, 124,  26, 132,  27, 136,  19, 140,  20, 155,  14, 159,  16,
				158,  18, 170,  13, 177,  10, 187,   8, 192,   6, 175,   9, 159,  10
			},
			/*Intra*/
			{
				21, 178,  59, 110,  71,  86,  75,  85,  84,  83,  91,  66,  88,  73,
				87,  72,  92,  75,  98,  72, 105,  58, 107,  54, 115,  52, 114,  55,
				112,  56, 129,  51, 132,  40, 150,  33, 140,  29,  98,  35,  77,  42
			}
		},
		/*960 sample frames.*/
		{
			/*Inter*/
			{
				42, 121,  96,  66, 108,  43, 111,  40, 117,  44, 123,  32, 120,  36,
				119,  33, 127,  33, 134,  34, 139,  21, 147,  23, 152,  20, 158,  25,
				154,  26, 166,  21, 173,  16, 184,  13, 184,  10, 150,  13, 139,  15
			},
			/*Intra*/
			{
				22, 178,  63, 114,  74,  82,  84,  83,  92,  82, 103,  62,  96,  72,
				96,  67, 101,  73, 107,  72, 113,  55, 118,  52, 125,  52, 118,  52,
				117,  55, 135,  49, 137,  39, 157,  32, 145,  29,  97,  33,  77,  40
			}
		}
	};

	private static final char small_energy_icdf[/* 3 */] = { 2, 1, 0 };// java uint8 to char

	private static final float loss_distortion(final float[] eBands,
			final float[] oldEBands, int start, int end, final int len, int C)
	{
		float dist = 0;
		C *= len;// java
		C += start;// java
		//int c = 0;
		do {
			for( int i = start; i < end; i++ )
			{
				final float d = eBands[i] - oldEBands[i];
				dist += d * d;
			}
			start += len;// java
			end += len;// java
		} while( start < C );
		return 200f < dist ? 200f : dist;
	}

	private static final int quant_coarse_energy_impl(final int nbands,// java replace CELTMode *m. FIXME why need CELTMode?
			final int start, final int end,
			final float[] bands,
			final float[] oldEBands,
			final int budget, int tell,
			final char[] prob_model, final float[] error, final Jec_enc enc,
			final int C, final int LM, final boolean intra, final float max_decay, final boolean lfe)
	{
		int badness = 0;
		final float prev[/* 2 */] = {0, 0};

		if( tell + 3 <= budget ) {
			enc.ec_enc_bit_logp( intra, 3 );
		}
		float coef;
		float beta;
		if( intra )
		{
			coef = 0;
			beta = beta_intra;
		} else {
			beta = beta_coef[LM];
			coef = pred_coef[LM];
		}

		/* Encode at a fixed coarse resolution */
		for( int i = start; i < end; i++ )
		{
			int c = 0;
			do {
				final int i_c_bands = i + c * nbands;// java, i + c * this.nbEBands;
				final float x = bands[i_c_bands];
				float oldE = oldEBands[i_c_bands];
				oldE = (-9.f >= oldE ? -9.f : oldE);
/* #ifdef FIXED_POINT
				f = SHL32( EXTEND32(x), 7 ) - PSHR32( MULT16_16(coef, oldE), 8 ) - prev[c];
				// Rounding to nearest integer here is really important!
				qi = (f + QCONST32(.5f, DB_SHIFT + 7)) >> (DB_SHIFT + 7);
				decay_bound = EXTRACT16( MAX32(-QCONST16( 28.f, DB_SHIFT ),
						SUB32((opus_val32)oldEBands[i + c * m.nbEBands], max_decay)) );
#else */
				final float f = x - coef * oldE - prev[c];
				/* Rounding to nearest integer here is really important! */
				int qi = (int)Math.floor( (double)(.5f + f) );
				float decay_bound = oldEBands[i_c_bands];
				decay_bound = (-28.f >= decay_bound ? -28.f : decay_bound) - max_decay;
// #endif
				/* Prevent the energy from going down too quickly (e.g. for bands
				that have just one bin) */
				if( qi < 0 && x < decay_bound )
				{
					qi += (int)(decay_bound - x);
					if( qi > 0 ) {
						qi = 0;
					}
				}
				int qi0 = qi;
				/* If we don't have enough bits to encode all the energy, just assume
				something safe. */
				tell = enc.ec_tell();
				final int bits_left = budget - tell - 3 * C * (end - i);
				if( i != start && bits_left < 30 )
				{
					if( bits_left < 24 ) {
						qi = 1 <= qi ? 1 : qi;
					}
					if( bits_left < 16 ) {
						qi = -1 >= qi ? -1 : qi;
					}
				}
				if( lfe && i >= 2 ) {
					qi = qi <= 0 ? qi : 0;
				}
				if( budget - tell >= 15 )
				{
					final int pi = (i <= 20 ? i : 20) << 1;
					qi = enc.ec_laplace_encode( qi, (int)prob_model[pi] << 7, (int)prob_model[pi + 1] << 6 );
				}
				else if( budget - tell >= 2 )
				{
					qi = qi <= 1 ? qi : 1;
					qi = -1 >= qi ? -1 : qi;
					enc.ec_enc_icdf( (qi << 1) ^ (qi < 0 ? -1 : 0), small_energy_icdf, 0, 2 );
				}
				else if( budget - tell >= 1 )
				{
					qi = 0 <= qi ? 0 : qi;
					enc.ec_enc_bit_logp( qi != 0, 1 );// FIXME why -qi ?
				} else {
					qi = -1;
				}
				error[i_c_bands] = f - qi;
				qi0 -= qi;// java
				if( qi0 < 0 ) {
					qi0 = -qi0;
				}
				badness += qi0;
				final float q = (float)qi;

				final float tmp = coef * oldE + prev[c] + q;
/* #ifdef FIXED_POINT
				tmp = MAX32( -QCONST32(28.f, DB_SHIFT + 7), tmp );
#endif */
				oldEBands[i_c_bands] = tmp;
				prev[c] = prev[c] + q - (beta * q);
			} while( ++c < C );
		}
		return lfe ? 0 : badness;
	}

	/**
	 * java changed: return new value of the delayedIntra
	 *
	 * @param m
	 * @param start
	 * @param end
	 * @param effEnd
	 * @param bands
	 * @param oldEBands
	 * @param budget
	 * @param error
	 * @param enc
	 * @param C
	 * @param LM
	 * @param nbAvailableBytes
	 * @param force_intra
	 * @param delayedIntra
	 * @param two_pass
	 * @param loss_rate
	 * @param lfe
	 * @return new value of the delayedIntra
	 */
	static final float quant_coarse_energy(final int nbands,// java replace CELTMode *m. FIXME why need CELTMode?
			final int start, final int end, final int effEnd,
			final float[] bands,
			final float[] oldEBands,
			final int budget,
			final float[] error, final Jec_enc enc, final int C, final int LM, final int nbAvailableBytes,
			final boolean force_intra, final float delayedIntra, boolean two_pass, final int loss_rate, final boolean lfe)
	{// FIXME budget is used as int32
		// SAVE_STACK;

		boolean intra = force_intra || (! two_pass && delayedIntra > ((float)((C << 1) * (end - start))) && nbAvailableBytes > (end - start) * C);
		final int intra_bias = (int)(((float)budget * delayedIntra * (float)loss_rate) / (float)(C << 9));
		final float new_distortion = loss_distortion( bands, oldEBands, start, effEnd, nbands, C );

		final int tell = enc.ec_tell();
		if( tell + 3 > budget ) {
			two_pass = intra = false;
		}

		float max_decay = 16.f;
		if( end - start > 10 )
		{
/* #ifdef FIXED_POINT
			max_decay = MIN32( max_decay, SHL32(EXTEND32(nbAvailableBytes), DB_SHIFT - 3));
#else */
			final float v = .125f * (float)nbAvailableBytes;
			max_decay = max_decay < v ? max_decay : v;
// #endif
		}
		if( lfe ) {
			max_decay = 3.f;
		}
		final Jec_enc enc_start_state = new Jec_enc( enc );

		final int cn = C * nbands;// java
		final float[] oldEBands_intra = new float[cn];
		final float[] error_intra = new float[cn];
		System.arraycopy( oldEBands, 0, oldEBands_intra, 0, cn );

		int badness1 = 0;
		if( two_pass || intra )
		{
			badness1 = quant_coarse_energy_impl( nbands, start, end, bands, oldEBands_intra, budget,// java changed
						tell, e_prob_model[LM][1], error_intra, enc, C, LM, true, max_decay, lfe );
		}

		if( ! intra )
		{
			final int tell_intra = enc.ec_tell_frac();

			final Jec_enc enc_intra_state = new Jec_enc( enc );

			final int nstart_bytes = enc_start_state.ec_range_bytes();
			final int nintra_bytes = enc_intra_state.ec_range_bytes();
			//intra_buf = ec_get_buffer(&enc_intra_state) + nstart_bytes;
			final byte[] buf = enc_intra_state.ec_get_buffer();// java
			final int intra_buf = enc_intra_state.ec_get_buffer_start() + nstart_bytes;// buf[ intra_buf ]. java: added ec_get_buffer_start
			int save_bytes = nintra_bytes - nstart_bytes;
			if( save_bytes == 0 ) {
				save_bytes = 0;
			}
			final byte[] intra_bits = new byte[save_bytes];
			/* Copy bits from intra bit-stream */
			System.arraycopy( buf, intra_buf, intra_bits, 0, nintra_bytes - nstart_bytes );

			enc.copyFrom( enc_start_state );// *enc = enc_start_state;s

			final int badness2 = quant_coarse_energy_impl( nbands, start, end, bands, oldEBands, budget,// java changed
							tell, e_prob_model[LM][intra ? 1 : 0], error, enc, C, LM, false, max_decay, lfe );

			if( two_pass && (badness1 < badness2 || (badness1 == badness2 && ((int)enc.ec_tell_frac()) + intra_bias > tell_intra)) )
			{
				enc.copyFrom( enc_intra_state );
				/* Copy intra bits to bit-stream */
				System.arraycopy( intra_bits, 0, buf, intra_buf, nintra_bytes - nstart_bytes );
				System.arraycopy( oldEBands_intra, 0, oldEBands, 0, cn );
				System.arraycopy( error_intra, 0, error, 0, cn );
				intra = true;
			}
		} else {
			System.arraycopy( oldEBands_intra, 0, oldEBands, 0, cn );
			System.arraycopy( error_intra, 0, error, 0, cn );
		}

		if( intra ) {
			return new_distortion;
		}
		return ((pred_coef[LM] * pred_coef[LM]) * delayedIntra) + new_distortion;

		// RESTORE_STACK;
	}

	final void unquant_coarse_energy(final int start, final int end,
			final float[] oldEBands,
			final boolean intra, final Jec_dec dec, final int C, final int LM)
	{
		final int bands = this.nbEBands;// java
		final char[] prob_model = e_prob_model[LM][intra ? 1 : 0];
		final float prev[/* 2 */] = { 0, 0 };
		float coef, beta;

		if( intra )
		{
			coef = 0;
			beta = beta_intra;
		} else {
			beta = beta_coef[LM];
			coef = pred_coef[LM];
		}

		final int budget = dec.storage << 3;

		/* Decode at a fixed coarse resolution */
		for( int i = start; i < end; i++ )
		{
			int c = 0;
			do {
				/* It would be better to express this invariant as a
				test on C at function entry, but that isn't enough
				to make the static analyzer happy. */
				// celt_sig_assert( c < 2 );
				final int tell = dec.ec_tell();
				int qi;
				if( budget - tell >= 15 )
				{
					final int pi = (i < 20 ? i : 20) << 1;
					qi = dec.ec_laplace_decode( (int)prob_model[pi] << 7, (int)prob_model[pi + 1] << 6 );
				}
				else if( budget - tell >= 2 )
				{
					qi = dec.ec_dec_icdf( small_energy_icdf, 0, 2 );
					qi = (qi >> 1) ^ -(qi & 1);
				}
				else if( budget - tell >= 1 )
				{
					qi = dec.ec_dec_bit_logp( 1 ) ? -1 : 0;
				} else {
					qi = -1;
				}
				final float q = (float)qi;

				final int cmb = i + c * bands;// java
				final float v = oldEBands[cmb];// java
				oldEBands[cmb] = -9.f >= v ? -9.f : v;
				final float tmp = (coef * oldEBands[cmb]) + prev[c] + q;
/* #ifdef FIXED_POINT
				tmp = MAX32( -QCONST32( 28.f, DB_SHIFT + 7), tmp );
#endif */
				oldEBands[cmb] = tmp;
				prev[c] += q - (beta * q);
			} while( ++c < C );
		}
	}

	public static final void amp2Log2(final int nbEBands,// java replace CELTMode *m. FIXME why need CELTMode?
			final int effEnd, final int end, final float[] bandE,
			final float[] bandLogE, final int bleoffset,// java
			int C)
	{
		C *= nbEBands;// java
		int c = 0;
		do {
			for( int i = 0, ic = c; i < effEnd; i++, ic++ ) {
				bandLogE[ bleoffset + ic ] = ((float)(1.442695040888963387 * Math.log( (double)bandE[ ic ] ))) - eMeans[i];
/* #ifdef FIXED_POINT
				// Compensate for bandE[] being Q12 but celt_log2() taking a Q14 input.
				bandLogE[i+c*m->nbEBands] += QCONST16(2.f, DB_SHIFT);
#endif */
			}
			for( int off = bleoffset + c, i = effEnd + off, ie = off + end; i < ie; i++ ) {
				bandLogE[ i ] = -14.f;
			}
			c += nbEBands;// java
		} while( c < C );
	}
	// end quant_bands.c

	// start rate.h, rate.c
	// rate.h
	// private static final int MAX_PSEUDO = 40;// java: uses only #ifdef CUSTOM_MODES
	private static final int LOG_MAX_PSEUDO = 6;

	// private static final int CELT_MAX_PULSES = 128;// java: uses only #ifdef CUSTOM_MODES

	static final int MAX_FINE_BITS = 8;

	private static final int FINE_OFFSET = 21;
	static final int QTHETA_OFFSET = 4;
	static final int QTHETA_OFFSET_TWOPHASE = 16;

	final int bits2pulses(final int band, int LM, int bits)
	{
		LM++;
		final char[] cache_bits = this.cache.bits;// java
		final int cache_index = this.cache.index[LM * this.nbEBands + band];// m.cache.bits[cache]

		int lo = 0;
		int hi = (int)cache_bits[cache_index];
		bits--;
		for( int i = 0; i < LOG_MAX_PSEUDO; i++ )
		{
			final int mid = (lo + hi + 1) >> 1;
			/* OPT: Make sure this is implemented with a conditional move */
			if( (int)cache_bits[cache_index + mid] >= bits ) {
				hi = mid;
			} else {
				lo = mid;
			}
		}
		if( bits - (lo == 0 ? -1 : (int)cache_bits[cache_index + lo]) <= (int)cache_bits[cache_index + hi] - bits ) {
			return lo;
		} else {
			return hi;
		}
	}

	final int pulses2bits(final int band, int LM, final int pulses)
	{
		LM++;
		return pulses == 0 ? 0 : (int)this.cache.bits[ this.cache.index[LM * this.nbEBands + band] + pulses ] + 1;
	}

	// rate.c

	private static final byte LOG2_FRAC_TABLE[/* 24 */] = {// uint8
		 0,
		 8, 13,
		16, 19, 21, 23,
		24, 26, 27, 28, 29, 30, 31, 32,
		32, 33, 34, 34, 35, 36, 36, 37, 37
	};

/* #ifdef CUSTOM_MODES

	/** Determines if V(N,K) fits in a 32-bit unsigned integer.
	N and K are themselves limited to 15 bits. */
/*	static int fits_in32(int _n, int _k)
	{
		static const opus_int16 maxN[15] = {
				32767, 32767, 32767, 1476, 283, 109,  60,  40,
				29,  24,  20,  18,  16,  14,  13};
		static const opus_int16 maxK[15] = {
				32767, 32767, 32767, 32767, 1172, 238,  95,  53,
				36,  27,  22,  18,  16,  15,  13};
		if( _n >= 14 )
		{
		if( _k >= 14 )
			return 0;
		else
			return _n <= maxN[_k];
		} else {
			return _k <= maxK[_n];
		}
	}

	void compute_pulse_cache(CELTMode *m, int LM)
	{
		int C;
		int i;
		int j;
		int curr = 0;
		int nbEntries = 0;
		int entryN[100], entryK[100], entryI[100];
		const opus_int16 *eBands = m.eBands;
		PulseCache *cache = &m.cache;
		opus_int16 *cindex;
		unsigned char *bits;
		unsigned char *cap;

		cindex = (opus_int16 *)opus_alloc( sizeof(cache.index[0]) * m.nbEBands * (LM + 2) );
		cache.index = cindex;

		// Scan for all unique band sizes
		for( i = 0; i <= LM + 1; i++ )
		{
			for( j = 0; j < m.nbEBands; j++ )
			{
				int k;
				int N = (eBands[j + 1] - eBands[j]) << i >> 1;
				cindex[i * m.nbEBands + j] = -1;
				// Find other bands that have the same size
				for( k = 0; k <= i; k++ )
				{
					int n;
					for( n = 0; n < m.nbEBands && (k != i || n < j); n++ )
					{
						if( N == (eBands[n + 1] - eBands[n]) << k >> 1 )
						{
							cindex[i * m.nbEBands + j] = cindex[k * m.nbEBands + n];
							break;
						}
					}
				}
				if( cache.index[i * m.nbEBands + j] == -1 && N != 0 )
				{
					int K;
					entryN[nbEntries] = N;
					K = 0;
					while( fits_in32( N, get_pulses( K + 1 ) ) && K < MAX_PSEUDO )
						K++;
					entryK[nbEntries] = K;
					cindex[i * m.nbEBands + j] = curr;
					entryI[nbEntries] = curr;

					curr += K + 1;
					nbEntries++;
				}
			}
		}
		bits = (unsigned char *)opus_alloc( sizeof(unsigned char)*curr );
		cache.bits = bits;
		cache.size = curr;
		// Compute the cache for all unique sizes
		for( i = 0; i < nbEntries; i++ )
		{
			unsigned char *ptr = bits+entryI[i];
			opus_int16 tmp[CELT_MAX_PULSES + 1];
			get_required_bits( tmp, entryN[i], get_pulses( entryK[i] ), BITRES );
			for( j = 1; j <= entryK[i]; j++ )
				ptr[j] = tmp[get_pulses(j)] - 1;
			ptr[0] = entryK[i];
		}

		// Compute the maximum rate for each band at which we'll reliably use as
		// many bits as we ask for.
		cache.caps = cap = (unsigned char *)opus_alloc( sizeof( cache.caps[0] ) * (LM + 1) * 2 * m.nbEBands );
		for( i = 0; i <= LM; i++ )
		{
			for( C = 1; C <= 2; C++ )
			{
				for( j = 0; j < m.nbEBands; j++ )
				{
					int N0;
					int max_bits;
					N0 = m.eBands[j + 1] - m.eBands[j];
					// N=1 bands only have a sign bit and fine bits.
					if( N0 << i == 1 )
						max_bits = C * (1 + MAX_FINE_BITS) << BITRES;
					else
					{
						const unsigned char *pcache;
						opus_int32           num;
						opus_int32           den;
						int                  LM0;
						int                  N;
						int                  offset;
						int                  ndof;
						int                  qb;
						int                  k;
						LM0 = 0;
						// Even-sized bands bigger than N=2 can be split one more time.
						// As of commit 44203907 all bands >1 are even, including custom modes.
						if( N0 > 2 )
						{
							N0 >>= 1;
							LM0--;
						}
						// N0=1 bands can't be split down to N<2.
						else if( N0 <= 1 )
						{
							LM0 = IMIN( i, 1 );
							N0 <<= LM0;
						}
						// Compute the cost for the lowest-level PVQ of a fully split band.
						pcache = bits + cindex[(LM0 + 1) * m.nbEBands + j];
						max_bits = pcache[pcache[0]] + 1;
						// Add in the cost of coding regular splits.
						N = N0;
						for( k = 0; k < i - LM0; k++ ) {
							max_bits <<= 1;
							// Offset the number of qtheta bits by log2(N)/2
							// + QTHETA_OFFSET compared to their "fair share" of
							// total/N
							offset = ((m.logN[j] + ((LM0 + k) << BITRES)) >> 1) - QTHETA_OFFSET;
							// The number of qtheta bits we'll allocate if the remainder
							// is to be max_bits.
							// The average measured cost for theta is 0.89701 times qb,
							// approximated here as 459/512.
							num = 459 * (opus_int32)((2 * N - 1) * offset + max_bits);
							den = ((opus_int32)(2 * N - 1) << 9) - 459;
							qb = IMIN( (num + (den >> 1)) / den, 57 );
							celt_assert( qb >= 0 );
							max_bits += qb;
							N <<= 1;
						}
						// Add in the cost of a stereo split, if necessary.
						if( C == 2 )
						{
							max_bits <<= 1;
							offset = ((m.logN[j] + (i << BITRES)) >> 1) - (N == 2 ? QTHETA_OFFSET_TWOPHASE : QTHETA_OFFSET);
							ndof = 2 * N - 1 - (N == 2);
							// The average measured cost for theta with the step PDF is
							// 0.95164 times qb, approximated here as 487/512.
							num = (N == 2 ? 512 : 487) * (opus_int32)(max_bits + ndof * offset);
							den = ((opus_int32)ndof << 9) - (N == 2 ? 512 : 487);
							qb = IMIN( (num + (den >> 1)) / den, (N == 2 ? 64 : 61) );
							celt_assert( qb >= 0 );
							max_bits += qb;
						}
						// Add the fine bits we'll use.
						// Compensate for the extra DoF in stereo
						ndof = C * N + ((C == 2 && N > 2) ? 1 : 0);
						// Offset the number of fine bits by log2(N)/2 + FINE_OFFSET
						// compared to their "fair share" of total/N
						offset = ((m.logN[j] + (i << BITRES)) >> 1) - FINE_OFFSET;
						// N=2 is the only point that doesn't match the curve
						if( N == 2 )
							offset += 1 << BITRES >> 2;
						// The number of fine bits we'll allocate if the remainder is to be max_bits.
						num = max_bits + ndof * offset;
						den = (ndof - 1) << BITRES;
						qb = IMIN( (num + (den >> 1)) / den, MAX_FINE_BITS );
						celt_assert( qb >= 0 );
						max_bits += C * qb << BITRES;
					}
					max_bits = (4 * max_bits / (C * ((m.eBands[j + 1] - m.eBands[j]) << i))) - 64;
					celt_assert( max_bits >= 0 );
					celt_assert( max_bits < 256 );
					*cap++ = (unsigned char)max_bits;
				}
			}
		}
	}

#endif */ /* CUSTOM_MODES */

	private static final int ALLOC_STEPS = 6;

	/**
	 * java changed: Jallocation_aux replaced _balance, intensity, dual_stereo
	 */
	private final int interp_bits2pulses(final int start, final int end, final int skip_start,
			final int[] bits1, final int[] bits2, final int[] thresh, final int[] cap, int total,
			// final int[] _balance,
			final Jallocation_aux aux,// java: _balance, intensity, dual_stereo
			final int skip_rsv,
			// final int[] intensity,
			int intensity_rsv,
			// final boolean[] dual_stereo,
			int dual_stereo_rsv, final int[] bits,
			final int[] ebits, final int[] fine_priority, final int C, final int LM, final Jec_ctx ec, final boolean encode,
			final int prev, final int signalBandwidth)
	{
		// SAVE_STACK;

		final int alloc_floor = C << Jec_ctx.BITRES;
		final int stereo = C > 1 ? 1 : 0;

		final int logM = LM << Jec_ctx.BITRES;
		int lo = 0;
		int hi = 1 << ALLOC_STEPS;
		for( int i = 0; i < ALLOC_STEPS; i++ )
		{
			final int mid = (lo + hi) >> 1;
			int psum = 0;
			boolean done = false;
			for( int j = end; j-- > start; )
			{
				final int tmp = bits1[j] + (mid * bits2[j] >> ALLOC_STEPS);
				if( tmp >= thresh[j] || done )
				{
					done = true;
					/* Don't allocate more than we can actually use */
					final int v = cap[j];// java
					psum += tmp <= v ? tmp : v;
				} else {
					if( tmp >= alloc_floor ) {
						psum += alloc_floor;
					}
				}
			}
			if( psum > total ) {
				hi = mid;
			} else {
				lo = mid;
			}
		}
		int psum = 0;
		/*printf ("interp bisection gave %d\n", lo);*/
		boolean done = false;
		for( int j = end; j-- > start; )
		{
			int tmp = bits1[j] + (lo * bits2[j] >> ALLOC_STEPS);
			if( tmp < thresh[j] && ! done )
			{
				if( tmp >= alloc_floor ) {
					tmp = alloc_floor;
				} else {
					tmp = 0;
				}
			} else {
				done = true;
			}
			/* Don't allocate more than we can actually use */
			final int v = cap[j];// java
			tmp = tmp <= v ? tmp : v;
			bits[j] = tmp;
			psum += tmp;
		}

		final short[] bands = this.eBands;// java
		int codedBands = -1;
		/* Decide which bands to skip, working backwards from the end. */
		for( codedBands = end; ; codedBands-- )
		{
			final int j = codedBands - 1;
			/* Never skip the first band, nor a band that has been boosted by
			   dynalloc.
			   In the first case, we'd be coding a bit to signal we're going to waste
			   all the other bits.
			   In the second case, we'd be coding a bit to redistribute all the bits
			   we just signaled should be cocentrated in this band. */
			if( j <= skip_start )
			{
				/* Give the bit we reserved to end skipping back. */
				total += skip_rsv;
				break;
			}
			/*Figure out how many left-over bits we would be adding to this band.
			  This can include bits we've stolen back from higher, skipped bands.*/
			int left = total - psum;
			final int percoeff = (left / (int)(bands[codedBands] - bands[start]));
			left -= (bands[codedBands] - bands[start]) * percoeff;
			left -= (bands[j] - bands[start]);// java
			int rem = left >= 0 ? left : 0;
			final int band_width = bands[codedBands] - bands[j];
			int band_bits = bits[j] + percoeff * band_width + rem;
			/*Only code a skip decision if we're above the threshold for this band.
			  Otherwise it is force-skipped.
			  This ensures that we have enough bits to code the skip flag.*/
			left = thresh[j];// java
			rem = alloc_floor + (1 << Jec_ctx.BITRES);// java
			if( band_bits >= (left > rem ? left : rem) )
			{
				if( encode )
				{
					/*This if() block is the only part of the allocation function that
					is not a mandatory part of the bitstream: any bands we choose to
					skip here must be explicitly signaled.*/
					int depth_threshold;
					/*We choose a threshold with some hysteresis to keep bands from
					  fluctuating in and out, but we try not to fold below a certain point. */
					if( codedBands > 17 ) {
						depth_threshold = j < prev ? 7 : 9;
					} else {
						depth_threshold = 0;
					}
/* #ifdef FUZZING
					if( (rand() & 0x1) == 0 )
#else */
					if( codedBands <= start + 2 || (band_bits > (depth_threshold * band_width << LM << Jec_ctx.BITRES) >> 4 && j <= signalBandwidth) )
// #endif
					{
						((Jec_enc)ec).ec_enc_bit_logp( true, 1 );
						break;
					}
					((Jec_enc)ec).ec_enc_bit_logp( false, 1 );
				} else if( ((Jec_dec)ec).ec_dec_bit_logp( 1 ) ) {
					break;
				}
				/*We used a bit to skip this band.*/
				psum += 1 << Jec_ctx.BITRES;
				band_bits -= 1 << Jec_ctx.BITRES;
			}
			/*Reclaim the bits originally allocated to this band.*/
			psum -= bits[j] + intensity_rsv;
			if( intensity_rsv > 0 ) {
				intensity_rsv = LOG2_FRAC_TABLE[j - start];
			}
			psum += intensity_rsv;
			if( band_bits >= alloc_floor )
			{
				/*If we have enough for a fine energy bit per channel, use it.*/
				psum += alloc_floor;
				bits[j] = alloc_floor;
			} else {
				/*Otherwise this band gets nothing at all.*/
				bits[j] = 0;
			}
		}

		// celt_assert( codedBands > start );
		/* Code the intensity and dual stereo parameters. */
		if( intensity_rsv > 0 )
		{
			if( encode )
			{
				aux.mIntensity = aux.mIntensity < codedBands ? aux.mIntensity : codedBands;
				((Jec_enc)ec).ec_enc_uint( aux.mIntensity - start, codedBands + 1 - start );
			} else {
				aux.mIntensity = start + ((Jec_dec)ec).ec_dec_uint( codedBands + 1 - start );
			}
		} else {
			aux.mIntensity = 0;
		}
		if( aux.mIntensity <= start )
		{
			total += dual_stereo_rsv;
			dual_stereo_rsv = 0;
		}
		if( dual_stereo_rsv > 0 )
		{
			if( encode ) {
				((Jec_enc)ec).ec_enc_bit_logp( aux.mDualStereo, 1 );
			} else {
				aux.mDualStereo = ((Jec_dec)ec).ec_dec_bit_logp(  1 );
			}
		} else {
			aux.mDualStereo = false;
		}

		/* Allocate the remaining bits */
		int left = total - psum;
		final int percoeff = left / (int)(bands[codedBands] - bands[start]);
		left -= (bands[codedBands] - bands[start]) * percoeff;
		for( int j = start; j < codedBands; j++ ) {
			bits[j] += ((int)percoeff * (bands[j + 1] - bands[j]));
		}
		for( int j = start; j < codedBands; j++ )
		{
			int tmp = bands[j + 1] - bands[j];
			tmp = left < tmp ? left : tmp;
			bits[j] += tmp;
			left -= tmp;
		}
		/*for( j=0;j<end;j++)printf("%d ", bits[j]);printf("\n");*/

		final short[] logs = this.logN;// java
		final int intensity = aux.mIntensity;// java
		final boolean dual_stereo = aux.mDualStereo;// java
		int balance = 0;
		int j;
		for( j = start; j < codedBands; j++ )
		{
			// celt_assert( bits[j] >= 0 );
			final int N0 = bands[j + 1] - bands[j];
			final int N = N0 << LM;
			final int bit = bits[j] + balance;

			int excess;
			if( N > 1 )
			{
				excess = bit - cap[j];// java
				excess = excess > 0 ? excess : 0;
				int bits_j = bit - excess;// java

				/* Compensate for the extra DoF in stereo */
				final int den = (C * N + ((C == 2 && N > 2 && ! dual_stereo && j < intensity) ? 1 : 0));

				final int NClogN = den * (logs[j] + logM);

				/* Offset for the number of fine bits by log2(N)/2 + FINE_OFFSET
				compared to their "fair share" of total/N */
				int offset = (NClogN >> 1) - den * FINE_OFFSET;

				/* N=2 is the only point that doesn't match the curve */
				if( N == 2 ) {
					offset += den << Jec_ctx.BITRES >> 2;
				}

				/* Changing the offset for allocating the second and third
				fine energy bit */
				if( bits_j + offset < (den << 1) << Jec_ctx.BITRES ) {
					offset += NClogN >> 2;
				} else if( bits_j + offset < den * 3 << Jec_ctx.BITRES ) {
					offset += NClogN >> 3;
				}

				/* Divide with rounding */
				int ebits_j = (bits_j + offset + (den << (Jec_ctx.BITRES - 1)));// java
				ebits_j = 0 >= ebits_j ? 0 : ebits_j;
				ebits_j = ( ebits_j / den ) >>> Jec_ctx.BITRES;

				/* Make sure not to bust */
				if( C * ebits_j > (bits_j >> Jec_ctx.BITRES) ) {
					ebits_j = bits_j >> stereo >> Jec_ctx.BITRES;
				}

				/* More than that is useless because that's about as far as PVQ can go */
				ebits_j = ebits_j < MAX_FINE_BITS ? ebits_j : MAX_FINE_BITS;
				ebits[j] = ebits_j;

				/* If we rounded down or capped this band, make it a candidate for the
				final fine energy pass */
				fine_priority[j] = ebits_j * (den << Jec_ctx.BITRES) >= bits_j + offset ? 1 : 0;

				/* Remove the allocated fine bits; the rest are assigned to PVQ */
				bits_j -= C * ebits_j << Jec_ctx.BITRES;
				bits[j] = bits_j;

			} else {
				/* For N=1, all bits go to fine energy except for a single sign bit */
				final int v = bit - (C << Jec_ctx.BITRES);// java
				excess = 0 >= v ? 0 : v;
				bits[j] = bit - excess;
				ebits[j] = 0;
				fine_priority[j] = 1;
			}

			/* Fine energy can't take advantage of the re-balancing in
			quant_all_bands().
			Instead, do the re-balancing here.*/
			if( excess > 0 )
			{
				int ebits_j = ebits[j];// java
				final int v = MAX_FINE_BITS - ebits_j;// java
				int extra_fine = excess >> (stereo + Jec_ctx.BITRES);
				extra_fine = extra_fine <= v ? extra_fine : v;
				ebits_j += extra_fine;
				ebits[j] = ebits_j;
				final int extra_bits = extra_fine * C << Jec_ctx.BITRES;
				fine_priority[j] = extra_bits >= excess - balance ? 1 : 0;
				excess -= extra_bits;
			}
			balance = excess;

			// celt_assert( bits[j] >= 0 );
			// celt_assert( ebits[j] >= 0 );
		}
		/* Save any remaining bits over the cap for the rebalancing in
		quant_all_bands(). */
		aux.mBalance = balance;

		/* The skipped bands use all their bits for fine energy. */
		for( ; j < end; j++ )
		{
			ebits[j] = bits[j] >> stereo >> Jec_ctx.BITRES;
			// celt_assert( C * ebits[j] << BITRES == bits[j] );
			bits[j] = 0;
			fine_priority[j] = ebits[j] < 1 ? 1 : 0;
		}
		// RESTORE_STACK;
		return codedBands;
	}

	/** Compute the pulse allocation, i.e. how many pulses will go in each
	 * band.
	 *
	 * java changed: intensity, dual_stereo, balance is replaced to aux
	 *
	 * @param m mode
	 * @param offsets Requested increase or decrease in the number of bits for each band
	 * @param total Number of bands
	 * @param pulses Number of pulses per band (returned)
	 * @return Total number of bits allocated
	 */
	final int clt_compute_allocation(final int start, final int end,
			final int[] offsets, final int[] cap, final int alloc_trim,
			// final int[] intensity, final boolean[] dual_stereo,// java replaced by aux
			final Jallocation_aux aux,// java
			int total,
			// final int[] balance,
			final int[] pulses, final int[] ebits, final int[] fine_priority,
			final int C, final int LM, final Jec_ctx ec, final boolean encode, final int prev, final int signalBandwidth)
	{
		// SAVE_STACK;

		total = total > 0 ? total : 0;
		final int len = this.nbEBands;
		int skip_start = start;
		/* Reserve a bit to signal the end of manually skipped bands. */
		final int skip_rsv = total >= 1 << Jec_ctx.BITRES ? 1 << Jec_ctx.BITRES : 0;
		total -= skip_rsv;
		/* Reserve bits for the intensity and dual stereo parameters. */
		int dual_stereo_rsv;
		int intensity_rsv = dual_stereo_rsv = 0;
		if( C == 2 )
		{
			intensity_rsv = LOG2_FRAC_TABLE[end - start];
			if( intensity_rsv > total ) {
				intensity_rsv = 0;
			} else
			{
				total -= intensity_rsv;
				dual_stereo_rsv = total >= 1 << Jec_ctx.BITRES ? 1 << Jec_ctx.BITRES : 0;
				total -= dual_stereo_rsv;
			}
		}
		final int[] thresh = new int[len];
		final int[] trim_offset = new int[len];
		final short[] bands = this.eBands;// java

		for( int j = start; j < end; j++ )
		{
			/* Below this threshold, we're sure not to allocate any PVQ bits */
			final int diff = (bands[j + 1] - bands[j]);// java
			final int v1 = C << Jec_ctx.BITRES;// java
			final int v2 = (3 * diff << LM << Jec_ctx.BITRES) >> 4;// java
			thresh[j] = v1 > v2 ? v1 : v2;
			/* Tilt of the allocation curve */
			trim_offset[j] = C * diff * (alloc_trim - 5 - LM) * (end - j - 1) * (1 << (LM + Jec_ctx.BITRES)) >> 6;
			/* Giving less resolution to single-coefficient bands because they get
			more benefit from having one coarse value per coefficient*/
			if( diff << LM == 1 ) {
				trim_offset[j] -= C << Jec_ctx.BITRES;
			}
		}
		int lo = 1;
		int hi = this.nbAllocVectors - 1;
		final char[] vectors = this.allocVectors;// java
		do
		{
			boolean done = false;
			int psum = 0;
			final int mid = (lo + hi) >> 1;
			for( int j = end; j-- > start; )
			{
				final int N = bands[j + 1] - bands[j];
				int bitsj = C * N * vectors[mid * len + j] << LM >> 2;
				if( bitsj > 0 ) {
					bitsj += trim_offset[j];
					bitsj = 0 > bitsj ? 0 : bitsj;
				}
				bitsj += offsets[j];
				if( bitsj >= thresh[j] || done )
				{
					done = true;
					/* Don't allocate more than we can actually use */
					final int v = cap[j];// java
					psum += bitsj < v ? bitsj : v;
				} else {
					if( bitsj >= C << Jec_ctx.BITRES ) {
						psum += C << Jec_ctx.BITRES;
					}
				}
			}
			if( psum > total ) {
				hi = mid - 1;
			} else {
				lo = mid + 1;
			}
			/*printf ("lo = %d, hi = %d\n", lo, hi);*/
		}
		while( lo <= hi );
		hi = lo--;
		/*printf ("interp between %d and %d\n", lo, hi);*/
		final int[] bits1 = new int[len];
		final int[] bits2 = new int[len];
		for( int j = start; j < end; j++ )
		{
			int bits1j, bits2j;
			final int N = bands[j + 1] - bands[j];
			bits1j = C * N * vectors[lo * len + j] << LM >> 2;
			bits2j = hi >= this.nbAllocVectors ?
						cap[j] : C * N * vectors[hi * len + j] << LM >> 2;
			if( bits1j > 0 ) {
				bits1j += trim_offset[j];
				bits1j = 0 > bits1j ? 0 : bits1j;
			}
			if( bits2j > 0 ) {
				bits2j += trim_offset[j];
				bits2j = 0 > bits2j ? 0 : bits2j;
			}
			if( lo > 0 ) {
				bits1j += offsets[j];
			}
			bits2j += offsets[j];
			if( offsets[j] > 0 ) {
				skip_start = j;
			}
			bits2j -= bits1j;
			bits2j = 0 > bits2j ? 0 : bits2j;
			bits1[j] = bits1j;
			bits2[j] = bits2j;
		}
		final int codedBands = interp_bits2pulses( start, end, skip_start, bits1, bits2, thresh, cap, total,
					// balance,
					aux,// java: balance, intensity, dual_stereo
					skip_rsv,
					// intensity,
					intensity_rsv,
					// dual_stereo,
					dual_stereo_rsv, pulses, ebits, fine_priority, C, LM, ec, encode, prev, signalBandwidth);
		// RESTORE_STACK;
		return codedBands;
	}
	// end rate.c

	// start celt_decoder.c
	final void celt_synthesis(final float[] X,
			final float[] st_mem, final int out_syn[],// java st_mem[ out_syn[] ]
			final float[] oldBandE,
			final int start, final int effEnd, final int C, final int CC,
			final boolean isTransient, final int LM, final int downsample,
			final boolean silence)//, final int arch)
	{
		//SAVE_STACK;

		final int over = this.overlap;
		final int nbands = this.nbEBands;
		final int N = this.shortMdctSize << LM;
		final float[] freq = new float[N]; /** < Interleaved signal MDCTs */
		final int M = 1 << LM;

		int B, NB, shift;
		if( isTransient )
		{
			B = M;
			NB = this.shortMdctSize;
			shift = this.maxLM;
		} else {
			B = 1;
			NB = this.shortMdctSize << LM;
			shift = this.maxLM - LM;
		}

		if( CC == 2 && C == 1 )
		{
			/* Copying a mono streams to two channels */
			denormalise_bands( X, 0, freq, 0, oldBandE, 0, start, effEnd, M, downsample, silence );
			/* Store a temporary copy in the output buffer because the IMDCT destroys its input. */
			final int freq2 = out_syn[1] + (over >> 1);// out_syn[1][freq2]
			System.arraycopy( freq, 0, st_mem, freq2, N );
			for( int b = 0; b < B; b++ ) {
				this.mdct.clt_mdct_backward( st_mem, freq2 + b, st_mem, out_syn[0] + NB * b, this.window, over, shift, B );//, arch );
			}
			for( int b = 0; b < B; b++ ) {
				this.mdct.clt_mdct_backward( freq, b, st_mem, out_syn[1] + NB * b, this.window, over, shift, B );//, arch );
			}
		} else if( CC == 1 && C == 2 )
		{
			/* Downmixing a stereo stream to mono */
			denormalise_bands( X, 0, freq, 0, oldBandE, 0, start, effEnd, M, downsample, silence );
			/* Use the output buffer as temp array before downmixing. */
			int freq2 = out_syn[0] + (over >> 1);// out_syn[0][freq2]
			denormalise_bands( X, N, st_mem, freq2, oldBandE, nbands, start, effEnd, M, downsample, silence );
			for( int i = 0; i < N; i++ ) {
				freq[i] = .5f * (freq[i] + st_mem[ freq2++ ]);// java. original: (.5f * freq[i] + .5f * st_mem[ freq2++ ])
			}
			for( int b = 0; b < B; b++ ) {
				this.mdct.clt_mdct_backward( freq, b, st_mem, out_syn[0] + NB * b, this.window, over, shift, B );//, arch );
			}
		} else {
			/* Normal case ( mono or stereo ) */
			int c = 0;
			do {
				denormalise_bands( X, c * N, freq, 0, oldBandE, c * nbands, start, effEnd, M, downsample, silence );
				for( int b = 0; b < B; b++ ) {
					this.mdct.clt_mdct_backward( freq, b, st_mem, out_syn[c] + NB * b, this.window, over, shift, B );//, arch );
				}
			} while ( ++c < CC );
		}
		/* Saturate IMDCT output so that we can't overflow in the pitch postfilter
		  or in the */
		/* int c = 0; do { // java: this loop isn't needed for the floating point version
			for( int i = 0; i < N; i++ )
				out_syn[c][i] = out_syn[c][i];
		} while( ++c < CC ); */
		//RESTORE_STACK;
	}
	// end celt_decoder.c

	// start celt_encoder.c
	/** Apply window and compute the MDCT for all sub - frames and
    all channels in a frame */
	final void compute_mdcts(final int shortBlocks, final float[] in,
			final float[] out, int C, final int CC, final int LM, final int upsample )//, final int arch )
	{
		final int over = this.overlap;
		int N, B, shift;
		if( 0 != shortBlocks )
		{
			B = shortBlocks;
			N = this.shortMdctSize;
			shift = this.maxLM;
		} else {
			B = 1;
			N = this.shortMdctSize << LM;
			shift = this.maxLM - LM;
		}
		final int bn = B * N;// java
		final Jmdct_lookup lookup = this.mdct;// java
		final float[] w = this.window;// java
		int c = 0;
		do {
			for( int b = 0; b < B; b++ )
			{
				/* Interleaving the sub-frames while doing the MDCTs */
				lookup.clt_mdct_forward( in, c * (bn + over) + b * N,
						out, b + c * bn, w, over, shift, B );//, arch );
			}
		} while( ++c < CC );
		if( CC == 2 && C == 1 )
		{
			for( int i = 0; i < bn; i++ ) {
				out[i] = .5f * out[i] + .5f * out[bn + i];
			}
		}
		if( upsample != 1 )
		{
			C *= bn;// java
			c = 0;
			do
			{
				final int bound = bn / upsample;
				for( int i = c, ie = i + bound; i < ie; i++ ) {
					out[i] *= upsample;
				}
				//OPUS_CLEAR( &out[c * B * N + bound], B * N - bound );
				for( int i = c + bound, end = i + bn - bound; i < end; i++ ) {
					out[i] = 0f;
				}
				c += bn;// java
			} while ( c < C );
		}
	}

	private static final float l1_metric(final float[] tmp, final int N, final int LM, final float bias )
	{
		float L1 = 0;
		for( int i = 0; i < N; i++ ) {
			float v = tmp[i];
			if( v < 0 ) {
				v = -v;
			}
			L1 += v;
		}
		/* When in doubt, prefer good freq resolution */
		L1 += LM * bias * L1;
		return L1;
	}

	/**
	 * java changed: return int64, (tf_sum << 32) | tf_select
	 * @param mode
	 * @param len
	 * @param isTransient
	 * @param tf_res
	 * @param lambda
	 * @param X
	 * @param N0
	 * @param LM
	 * @param tf_estimate
	 * @param tf_chan
	 * @param importance
	 * @return int32 tf_select
	 */
	final int tf_analysis(final int len, final boolean isTransient,
			final int[] tf_res, final int lambda, final float[] X, final int N0, final int LM,
			final float tf_estimate, final int tf_chan, final int[] importance)
	{
		final int selcost[] = new int[2];
		int tf_select = 0;

		// SAVE_STACK;
		float bias = .5f - tf_estimate;
		bias = -.25f >= bias ? -.25f : bias;
		bias *= .04f;
		/*printf( "%f ", bias ); */

		final short[] bands = this.eBands;// java
		final int[] metric = new int[len];
		final float[] tmp = new float[( bands[len] - bands[len - 1] ) << LM];
		final float[] tmp_1 = new float[( bands[len] - bands[len - 1] ) << LM];
		final int[] path0 = new int[len];
		final int[] path1 = new int[len];

		for( int i = 0; i < len; i++ )
		{
			int best_level = 0;
			final int N = ( bands[i + 1] - bands[i] ) << LM;
			/* band is too narrow to be split down to LM = - 1 */
			final boolean narrow = ( bands[i + 1] - bands[i] ) == 1;
			System.arraycopy( X, tf_chan * N0 + ( bands[i] << LM ), tmp, 0, N );
			/* Just add the right channel if we're in stereo */
			/*if( C == 2 )
				for( j = 0; j < N; j++ )
					tmp[j] = ADD16( SHR16( tmp[j], 1 ), SHR16( X[N0 + j + ( m.eBands[i] << LM )], 1 ) ); */
			float L1 = l1_metric( tmp, N, isTransient ? LM : 0, bias );
			float best_L1 = L1;
			/* Check the -1 case for transients */
			if( isTransient && ! narrow )
			{
				System.arraycopy( tmp, 0, tmp_1, 0, N );
				Jband_ctx.haar1( tmp_1, 0, N >> LM, 1 << LM );
				L1 = l1_metric( tmp_1, N, LM + 1, bias );
				if( L1 < best_L1 )
				{
					best_L1 = L1;
					best_level = -1;
				}
			}
			/*printf ( "%f ", L1 ); */
			for( int k = 0, ke = LM + ((isTransient || narrow) ? 0 : 1); k < ke; k++ )
			{
				int B;

				if( isTransient ) {
					B = (LM - k - 1);
				} else {
					B = k + 1;
				}

				Jband_ctx.haar1( tmp, 0, N >> k, 1 << k );

				L1 = l1_metric( tmp, N, B, bias );

				if( L1 < best_L1 )
				{
					best_L1 = L1;
					best_level = k + 1;
				}
			}
			/*printf ( "%d ", isTransient ? LM - best_level : best_level ); */
			/* metric is in Q1 to be able to select the mid-point ( -0.5 ) for narrower bands */
			if( isTransient ) {
				metric[i] = best_level << 1;
			} else {
				metric[i] = -(best_level << 1);
			}
			/* For bands that can't be split to  - 1, set the metric to the half - way point to avoid
			   biasing the decision */
			if( narrow && ( metric[i] == 0 || metric[i] == -(LM << 1) ) ) {
				metric[i] -= 1;
			}
			/*printf("%d ", metric[i]/2 + (!isTransient)*LM);*/
		}
		/*printf( "\n" ); */
		/* Search for the optimal tf resolution, including tf_select */
		final byte[] table_lm = tf_select_table[LM];// java
		tf_select = 0;
		for( int sel = 0, ti = isTransient ? 4 : 0; sel < 2; sel++, ti += 2 )
		{
			final int t0 = table_lm[ ti ] << 1;// java
			final int t1 = table_lm[ ti + 1 ] << 1;// java
			// int cost0 = importance[0] * abs( metric[0] - 2 * table_lm[4 * isTransient + 2 * sel + 0]);
			// int cost1 = importance[0] * abs( metric[0] - 2 * table_lm[4 * isTransient + 2 * sel + 1]) + (isTransient ? 0 : lambda);
			int v = metric[0];// java
			int cost0 = v - t0;
			int cost1 = v - t1;
			v = importance[0];// java
			if( cost0 < 0 ) {
				cost0 = -cost0;
			}
			cost0 *= v;
			if( cost1 < 0 ) {
				cost1 = -cost1;
			}
			cost1 *= v;
			cost1 += (isTransient ? 0 : lambda);
			for( int i = 1; i < len; i++ )
			{
				int curr0 = cost1 + lambda;
				curr0 = cost0 <= curr0 ? cost0 : curr0;
				int curr1 = cost0 + lambda;
				curr1 = curr1 <= cost1 ? curr1 : cost1;
				v = metric[ i ];// java
				cost0 = v - t0;// java
				cost1 = v - t1;
				v = importance[ i ];// java
				if( cost0 < 0 ) {
					cost0 = -cost0;
				}
				cost0 *= v;
				cost0 += curr0;
				if( cost1 < 0 ) {
					cost1 = -cost1;
				}
				cost1 *= v;
				cost1 += curr1;
			}
			selcost[sel] = cost0 <= cost1 ? cost0 : cost1;
		}
			/* For now, we're conservative and only allow tf_select = 1 for transients.
			* If tests confirm it's useful for non - transients, we could allow it. */
		if( selcost[1] < selcost[0] && isTransient ) {
			tf_select = 1;
		}
		final int ti = isTransient ? 4 + (tf_select << 1) : (tf_select << 1);// java
		final int t0 = table_lm[ ti ] << 1;// java
		final int t1 = table_lm[ ti + 1 ] << 1;// java
		int v = metric[ 0 ];// java
		int cost0 = v - t0;
		int cost1 = v - t1;
		v = importance[ 0 ];
		if( cost0 < 0 ) {
			cost0 = -cost0;
		}
		if( cost1 < 0 ) {
			cost1 = -cost1;
		}
		cost0 *= v;
		cost1 *= v;
		cost1 += (isTransient ? 0 : lambda);
		/* Viterbi forward pass */
		for( int i = 1; i < len; i++ )
		{
			int curr0, curr1;

			int from0 = cost0;
			int from1 = cost1 + lambda;
			if( from0 < from1 )
			{
				curr0 = from0;
				path0[i] = 0;
			} else {
				curr0 = from1;
				path0[i] = 1;
			}

			from0 = cost0 + lambda;
			from1 = cost1;
			if( from0 < from1 )
			{
				curr1 = from0;
				path1[i] = 0;
			} else {
				curr1 = from1;
				path1[i] = 1;
			}
			v = metric[ i ];
			cost0 = v - t0;
			cost1 = v - t1;
			v = importance[ i ];
			if( cost0 < 0 ) {
				cost0 = -cost0;
			}
			if( cost1 < 0 ) {
				cost1 = -cost1;
			}
			cost0 *= v;
			cost0 += curr0;
			cost1 *= v;
			cost1 += curr1;
		}
		tf_res[len - 1] = cost0 < cost1 ? 0 : 1;
		/* Viterbi backward pass to check the decisions */
		for( int i = len - 2; i >= 0; i-- )
		{
			tf_res[i] = tf_res[i + 1] == 1 ? path1[i + 1] : path0[i + 1];
		}
		/*printf( "%d %f\n", *tf_sum, tf_estimate ); */
		// RESTORE_STACK;
/* #ifdef FUZZING
		tf_select = rand() & 0x1;
		tf_res[0] = rand() & 0x1;
		for( i = 1; i < len; i++ )
			tf_res[i] = tf_res[i - 1] ^ ((rand() & 0xF) == 0);
#endif */
		return tf_select;
	}

	final int alloc_trim_analysis(final float[] X,
			final float[] bandLogE, final int end, final int LM, final int C, final int N0,
			final JAnalysisInfo analysis, final float[] stereo_saving, final float tf_estimate,
			final int intensity, final float surround_trim, final int equiv_rate )//, final int arch )
	{
		final short[] bands = this.eBands;// java
		float diff = 0;
		float trim = 5.f;
		/* At low bitrate, reducing the trim seems to help. At higher bitrates, it's less
		  clear what's best, so we're keeping it as it was before, at least for now. */
		if( equiv_rate < 64000 ) {
			trim = 4.f;
		} else if( equiv_rate < 80000 ) {
			final int frac = (equiv_rate - 64000) >> 10;
			trim = 4.f + (1.f / 16.f) * frac;
		}
		if( C == 2 )
		{
			float sum = 0;  /* Q10 */
			/* Compute inter - channel correlation for low frequencies */
			for( int i = 0; i < 8; i++ )
			{
				final short mbi = bands[i];// java
				final int v = mbi << LM;// java
				final float partial = celt_inner_prod( X, v, X, N0 + v, (bands[i + 1] - mbi) << LM );//, arch );
				sum += partial;
			}
			sum *= (1.f / 8f);
			if( sum < 0 ) {
				sum = -sum;
			}
			sum = 1.f <= sum ? 1.f : sum;
			float minXC = sum;  /* Q10 */
			for( int i = 8; i < intensity; i++ )
			{
				final short mbi = bands[i];// java
				final int v = mbi << LM;// java
				float partial = celt_inner_prod( X, v, X, N0 + v, (bands[i + 1] - mbi) << LM );//, arch );
				if( partial < 0 ) {
					partial = -partial;
				}
				minXC = minXC <= partial ? minXC : partial;
			}
			if( minXC < 0 ) {
				minXC = -minXC;
			}
			minXC = 1.f <= minXC ? 1.f : minXC;
			/*printf ( "%f\n", sum ); */
			/* mid - side savings estimations based on the LF average*/
			float logXC = (float)(1.442695040888963387 * Math.log( (double)(1.001f - sum * sum) ));
			/* mid - side savings estimations based on min correlation */
			minXC = (float)(1.442695040888963387 * Math.log( (double)(1.001f - minXC * minXC) ));
			float v = .5f * logXC;// java
			float logXC2 = v > minXC ? v : minXC;
/* #ifdef FIXED_POINT
			// Compensate for Q20 vs Q14 input and convert output to Q8
			logXC = PSHR32( logXC - QCONST16( 6.f, DB_SHIFT ),DB_SHIFT - 8 );
			logXC2 = PSHR32( logXC2 - QCONST16( 6.f, DB_SHIFT ),DB_SHIFT - 8 );
#endif */

			logXC *= .75f;
			trim += -4.f > logXC ? -4.f : logXC;
			logXC2 *= -.5f;
			v = stereo_saving[0] + 0.25f;
			stereo_saving[0] = v < logXC2 ? v : logXC2;
		}

		/* Estimate spectral tilt */
		final int cn = C * this.nbEBands;// java
		int c = 0;
		do {
			for( int i = 0, ie = end - 1; i < ie; i++ )
			{
				diff += bandLogE[i + c] * (2 + (i << 1) - end);
			}
			c += this.nbEBands;// java
		} while( c < cn );
		diff /= C * (end - 1);
		/*printf( "%f\n", diff ); */
		diff = (diff + 1.f) / 6f;
		diff = 2.f <= diff ? 2.f : diff;
		trim -= -2.f >= diff ? -2.f : diff;
		trim -= surround_trim;
		trim -= 2f * tf_estimate;
//#ifndef DISABLE_FLOAT_API
		if( analysis.valid )
		{
			float v = 2.f * (analysis.tonality_slope + .05f);// java
			v = 2.f <= v ? 2.f : v;
			trim -= -2.f >= v ? -2.f : v;
		}
/* #else
		(void)analysis;
#endif */

/* #ifdef FIXED_POINT
		trim_index = PSHR32( trim, 8 );
#else */
		int trim_index = (int)Math.floor( (double)(.5f + trim) );
//#endif
		trim_index = 10 <= trim_index ? 10 : trim_index;
		trim_index = 0 >= trim_index ? 0 : trim_index;
		/*printf( "%d\n", trim_index ); */
/* #ifdef FUZZING
		trim_index = rand() % 11;
#endif */
		return trim_index;
	}
	// end celt_encoder.c
}
