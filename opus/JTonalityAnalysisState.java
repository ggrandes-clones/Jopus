package opus;

import celt.JAnalysisInfo;
import celt.JCELTMode;
import celt.Jcelt;
import celt.Jkiss_fft_cpx;
import celt.Jkiss_fft_state;

/* Copyright (c) 2011 Xiph.Org Foundation
   Written by Jean-Marc Valin */

// analysis.c

final class JTonalityAnalysisState {
	private static final int NB_FRAMES = 8;
	private static final int NB_TBANDS = 18;
	private static final int ANALYSIS_BUF_SIZE = 720; /* 30 ms at 24 kHz */

	/* At that point we can stop counting frames because it no longer matters. */
	private static final int ANALYSIS_COUNT_MAX = 10000;

	private static final int DETECT_SIZE = 100;

	/* Uncomment this to print the MLP features on stdout. */
	/*#define MLP_TRAINING*/

	// start mlp_data.c
	/*This file is automatically generated from a Keras model*/
	private static final byte layer0_weights[] = {// [800] = {
	   -30, -9, 2, -12, 5, -1, 8, 9,
	   9, 8, -13, 18, -17, -34, -5, 17,
	   -11, 0, -4, 10, 2, 10, 15, -8,
	   2, -1, 0, 5, 13, -3, -16, 1,
	   -5, 3, 7, -28, -13, 6, 36, -3,
	   19, -60, -17, -28, 7, -11, -30, -7,
	   2, -42, -21, -3, 6, -22, 33, -9,
	   7, -30, 21, -14, 24, -11, -20, -18,
	   -5, -12, 12, -49, -50, -49, 16, 9,
	   -37, -1, 9, 34, -13, -31, -31, 12,
	   16, 44, -42, 2, -9, 8, -18, -6,
	   9, 36, 19, 11, 13, 12, -21, 3,
	   -28, -12, 3, 33, 25, -14, 11, 1,
	   -94, -39, 18, -12, -11, -15, -7, 49,
	   52, 10, -43, 9, 57, 8, 21, -6,
	   14, -15, 44, -8, 7, -30, -13, -2,
	   -9, 25, -2, -127, 18, -11, -52, 26,
	   -27, 27, 10, -10, 7, 43, 6, -24,
	   41, 10, -18, -27, 10, 17, 9, 10,
	   -17, -10, 20, -6, 22, 55, 35, -80,
	   36, 25, -24, -36, 15, 9, -19, 88,
	   19, 64, -51, -35, 17, 0, -7, 41,
	   -16, 27, 4, 15, -1, 18, -16, 47,
	   -39, -54, -8, 13, -25, -20, 102, -18,
	   -5, 44, 11, -28, 71, 2, -51, -5,
	   5, 2, -83, -9, -29, 8, 21, -53,
	   58, -37, -7, 13, 38, 9, 34, -1,
	   -41, 21, 4, -24, -36, -33, -21, 32,
	   75, -2, 1, -68, -1, 47, -29, 32,
	   20, 12, -65, -87, 5, 16, -12, 24,
	   40, 15, 7, 19, -26, -17, 17, 6,
	   -2, -37, -30, -9, 32, -127, -39, 0,
	   -31, -27, 4, -22, 23, -6, -77, 35,
	   -61, 32, -37, -24, 13, -11, -1, -40,
	   -3, 17, -7, 13, 11, 59, -19, 10,
	   6, -18, 0, 13, 3, -6, -23, 19,
	   11, -17, 13, -1, -80, 40, -53, 69,
	   -29, -54, 0, -4, 33, -25, -2, 38,
	   35, 36, -15, 46, 2, -13, -16, -8,
	   -8, 12, -24, -9, -55, -5, -9, 32,
	   11, 7, 12, -18, -10, -86, -38, 54,
	   37, -25, 18, -43, 7, -27, -27, -54,
	   13, 9, 22, 70, 6, 35, -7, 23,
	   -15, -44, -6, 7, -66, -85, 32, 40,
	   -19, -9, -7, 12, -15, 7, 2, 6,
	   -35, 11, 28, 0, 26, 14, 1, 1,
	   4, 12, 18, 35, 22, -18, -3, 14,
	   -1, 7, 14, -8, -14, -3, 4, -3,
	   -19, -7, -1, -25, -27, 25, -26, -2,
	   33, -22, -27, -25, 4, -9, 7, 21,
	   26, -30, 10, -9, -20, 11, 27, 10,
	   5, -18, 14, -4, 2, -17, -5, -7,
	   -9, -13, 15, 29, 1, -10, -16, -10,
	   35, 36, -7, -22, -44, 17, 30, 22,
	   21, -1, 22, -11, 32, -8, -7, 5,
	   -10, 5, 30, -20, 29, -20, -34, 12,
	   -4, -6, 6, -13, 10, -5, -68, -1,
	   24, 9, 19, -24, -64, 31, 19, 27,
	   -26, 75, -45, 41, 39, -42, 8, 6,
	   23, -30, 16, -25, 30, 34, 8, -38,
	   -3, 18, 16, -31, 22, -4, -9, 1,
	   20, 9, 38, -32, 0, -45, 0, -6,
	   -13, 11, -25, -32, -22, 31, -24, -11,
	   -11, -4, -4, 20, -34, 22, 20, 9,
	   -25, 27, -5, 28, -29, 29, 6, 21,
	   -6, -18, 54, 4, -46, 23, 21, -14,
	   -31, 36, -41, -24, 4, 22, 10, 11,
	   7, 36, -32, -13, -52, -17, 24, 28,
	   -37, -36, -1, 24, 9, -38, 35, 48,
	   18, 2, -1, 45, 10, 39, 24, -38,
	   13, 8, -16, 8, 25, 11, 7, -29,
	   -11, 7, 20, -30, -38, -45, 14, -18,
	   -28, -9, 65, 61, 22, -53, -38, -16,
	   36, 46, 20, -39, 32, -61, -6, -6,
	   -36, -33, -18, -28, 56, 101, 45, 11,
	   -28, -23, -29, -61, 20, -47, 2, 48,
	   27, -17, 1, 40, 1, 3, -51, 15,
	   35, 28, 22, 35, 53, -61, -29, 12,
	   -6, -21, 10, 3, -20, 2, -25, 1,
	   -6, 31, 11, -3, 1, -10, -52, 6,
	   126, -105, 122, 127, -128, 127, 127, -128,
	   127, 108, 12, 127, 48, -128, -36, -128,
	   127, 127, -128, -128, 127, 89, -128, 127,
	   -128, -128, -128, 127, 127, -128, -128, -93,
	   -82, 20, 125, 65, -82, 127, 38, -74,
	   81, 88, -88, 79, 51, -47, -111, -26,
	   14, 83, -88, -112, 24, 35, -101, 98,
	   -99, -48, -45, 46, 83, -60, -79, 45,
	   -20, -41, 9, 4, 52, 54, 93, -10,
	   4, 13, 3, 123, 6, 94, -111, -69,
	   -14, -31, 10, 12, 53, -79, -11, -21,
	   -2, -44, -72, 92, 65, -57, 56, -38,
	   127, -56, -128, 127, 127, -128, 86, 117,
	   -75, -128, 127, -19, -99, -112, 127, -128,
	   127, -48, 114, 118, -128, -128, 117, -17,
	   -6, 121, -128, 127, -128, 82, 54, -106,
	   127, 127, -33, 100, -39, -23, 18, -78,
	   -34, -29, -1, -30, 127, -26, 127, -128,
	   126, -128, 27, -23, -79, -120, -127, 127,
	   72, 66, 29, 7, -66, -56, -117, -128
	};

	private static final byte layer0_bias[] = {// [32] = {
	   51, -16, 1, 13, -5, -6, -16, -7,
	   11, -6, 106, 26, 28, -14, 21, -29,
	   7, 18, -18, -17, 21, -17, -9, 20,
	   -25, -3, -34, 48, 11, -13, -31, -20
	};

	private static final byte layer1_weights[] = {// [2304] = {
	   22, -1, -7, 7, 29, -27, -31, -17,
	   -13, 33, 44, -8, 11, 33, 24, 78,
	   15, 19, 30, -2, -24, 5, 49, 5,
	   36, 29, -14, -11, -48, -33, 21, -42,
	   -38, -12, 55, -37, 54, -8, 1, 36,
	   17, 0, 51, 31, 59, 7, -12, 53,
	   4, 32, -14, 48, 5, -10, -16, -8,
	   1, -16, -56, -24, -6, 18, -2, 23,
	   6, 46, -6, -10, 20, 35, -44, -15,
	   -49, 36, 16, 5, -7, -79, -67, 12,
	   70, -3, -79, -54, -85, -24, 47, -22,
	   33, 21, 69, -1, 11, 22, 14, -16,
	   -16, -22, -28, -11, 11, -41, 31, -26,
	   -33, -19, -4, 27, 32, -50, 5, -10,
	   -38, -22, -8, 35, -31, 1, -41, -15,
	   -11, 44, 28, -17, -41, -23, 17, 2,
	   -23, -26, -13, -13, -17, 6, 14, -31,
	   -25, 9, -19, 39, -8, 4, 31, -1,
	   -45, -11, -28, -92, -46, -15, 21, 118,
	   -22, 45, -51, 11, -20, -20, -15, 13,
	   -21, -97, -29, -32, -23, -42, 94, 1,
	   23, -8, 63, -3, -46, 19, -26, 32,
	   -40, -74, -26, 26, -4, -13, 30, -20,
	   -30, -25, -14, -31, -45, -43, 4, -60,
	   -48, -12, -34, 2, 2, 3, 13, 15,
	   11, 16, 5, 46, -9, -55, -16, -57,
	   29, 14, 38, -50, -2, -44, -11, -8,
	   52, -27, -38, -7, 20, 47, 17, -59,
	   0, 47, 46, -63, 35, -17, 19, 33,
	   68, -19, 2, 15, -16, 28, -16, -103,
	   26, -35, 47, -39, -60, 30, 31, -23,
	   -52, -13, 116, 47, -25, 30, 40, 30,
	   -22, 2, 12, -27, -18, 31, -10, 27,
	   -8, -66, 12, 14, 4, -26, -28, -13,
	   3, 13, -26, -51, 37, 5, 2, -21,
	   47, 3, 13, 25, -41, -27, -8, -4,
	   5, -76, -33, 28, 10, 9, -46, -74,
	   19, 28, 25, 31, 54, -55, 68, 38,
	   -24, -32, 2, 4, 68, 11, -1, 99,
	   5, 16, -2, -74, 40, 26, -26, 33,
	   31, -1, -68, 14, -6, 25, 9, 29,
	   60, 61, 7, -7, 0, -24, 7, 77,
	   4, -1, 16, -7, 13, -15, -19, 28,
	   -31, -24, -16, 37, 24, 13, 30, 10,
	   -30, 11, 11, -10, 22, 60, 28, 45,
	   -3, -40, -62, -5, -102, 9, -32, -27,
	   -54, 21, 15, -5, 37, -43, -11, 37,
	   -19, 47, -64, -128, -27, -114, 21, -66,
	   59, 46, -3, -12, -87, -9, 4, 19,
	   -113, -36, 78, 57, -26, -38, -77, -10,
	   6, 6, -75, 25, -97, -11, 33, -46,
	   1, 13, -21, -33, -20, 16, -6, -3,
	   -11, -4, -27, 38, 8, -41, -2, -33,
	   18, 19, -26, 1, -29, -22, -4, -14,
	   -55, -11, -80, -3, 11, 34, 90, 51,
	   11, 17, 43, 36, 127, -32, 29, 103,
	   9, 27, 13, 64, 56, 70, -14, 3,
	   -12, 10, 37, 3, 12, -22, -10, 46,
	   28, 10, 20, 26, -24, 18, 9, 7,
	   14, 34, -5, -7, 31, -14, -56, 11,
	   -18, -8, -17, -7, -10, -40, 10, -33,
	   -32, -43, 5, 9, 11, -4, 10, 50,
	   -12, -5, 46, 9, 7, 1, 11, 15,
	   91, -17, 7, -50, 23, 6, -30, -99,
	   0, -17, 14, 8, -10, -25, -30, -69,
	   -62, 31, 127, 114, -23, 101, -5, -54,
	   -6, -22, 7, -56, 39, 18, -29, 0,
	   46, 8, -79, 4, -21, 18, -32, 62,
	   -12, -8, -12, -58, 31, -32, 17, 6,
	   -24, 25, 24, 9, -4, -19, 45, 6,
	   17, -14, 5, -27, 16, -4, -41, 25,
	   -36, 5, 15, 12, 50, 27, 25, 23,
	   -44, -69, -9, -19, -48, -8, 4, 12,
	   -6, 13, -19, -30, -36, 26, 37, -1,
	   -3, -30, -42, -14, -10, -20, 26, -54,
	   -27, -44, 4, 73, -26, 90, 32, -69,
	   -29, -16, 3, 103, 15, -17, 37, 24,
	   -23, -31, 33, -37, -64, 25, 13, -81,
	   -28, -32, 27, 5, -35, -23, 15, -22,
	   19, -7, 9, 30, 19, -23, 27, -13,
	   43, 29, -29, -6, 9, -40, -33, -33,
	   -32, 9, 11, -48, -8, -23, -52, 46,
	   17, -22, -42, 35, -15, -41, 16, 34,
	   31, -42, -19, -11, 55, 7, -39, 89,
	   -11, -33, 20, -14, 22, 32, 3, -17,
	   -6, 14, 34, 1, 55, -21, -90, -8,
	   18, 27, 13, -29, 21, 15, -33, -51,
	   -9, -11, 4, -16, -18, 23, -4, -4,
	   48, 1, 7, 29, -14, -12, -16, 17,
	   35, 8, 0, -7, -2, 9, 8, 17,
	   -6, 53, -32, -21, -50, 5, 99, -60,
	   -5, -53, 10, -31, 12, -5, 7, 80,
	   36, 18, -31, 9, 98, 36, -63, -35,
	   4, -13, -28, -24, 28, -13, 18, 16,
	   -1, -18, -34, 10, 20, 7, 4, 29,
	   11, 25, -7, 36, 14, 45, 24, 1,
	   -16, 30, 6, 35, -6, -11, -24, 13,
	   -1, 27, 39, 20, 48, -11, -4, -13,
	   28, 11, -31, -18, 31, -29, 22, -2,
	   -20, -16, 5, 30, -12, -28, -3, 93,
	   -16, 23, 18, -29, 6, -54, -37, 28,
	   -3, -3, -47, -3, -36, -55, -3, 41,
	   -10, 47, -2, 23, 42, -7, -71, -27,
	   83, -64, 7, -24, 8, 26, -17, 15,
	   12, 31, -30, -38, -13, -33, -56, 4,
	   -17, 20, 18, 1, -30, -5, -6, -31,
	   -14, -37, 0, 22, 10, -30, 37, -17,
	   18, 6, 5, 23, -36, -32, 14, 18,
	   -13, -61, -52, -69, 44, -30, 16, 18,
	   -4, -25, 14, 81, 26, -8, -23, -59,
	   52, -104, 17, 119, -32, 26, 17, 1,
	   23, 45, 29, -64, -57, -14, 73, 21,
	   -13, -13, 9, -68, -7, -52, 3, 24,
	   -39, 44, -15, 27, 14, 19, -9, -28,
	   -11, 5, 3, -34, -2, 2, 22, -6,
	   -23, 4, 3, 13, -22, -13, -10, -18,
	   29, 6, 44, -13, -24, -8, 2, 30,
	   14, 43, 6, 17, -73, -6, -7, 20,
	   -80, -7, -7, -28, 15, -69, -38, -5,
	   -100, -35, 15, -79, 23, 29, -18, -27,
	   21, -66, -37, 8, -22, -39, 48, 4,
	   -13, 1, -9, 11, -29, 22, 6, -49,
	   32, -14, 47, -18, -4, 44, -52, -74,
	   43, 30, 23, -14, 5, 0, -27, 4,
	   -7, 10, -4, 10, 1, -16, 11, -18,
	   -2, -5, 2, -11, 0, -20, -4, 38,
	   74, 59, 39, 64, -10, 26, -3, -40,
	   -68, 3, -30, -51, 8, -19, -27, -46,
	   51, 52, 54, 36, 90, 92, 14, 13,
	   -5, 0, 16, -62, 16, 11, -47, -37,
	   -6, -5, 21, 54, -57, 32, 42, -6,
	   62, -9, 16, 21, 24, 9, -10, -4,
	   33, 50, 13, -15, 1, -35, -48, 18,
	   -11, -17, -67, -13, 21, 38, -44, 36,
	   -16, 29, 17, 5, -10, 18, 17, -32,
	   2, 8, 22, -56, -15, -32, 40, 43,
	   19, 46, -7, -100, -96, 19, 53, 24,
	   21, -26, -48, -101, -82, 61, 38, -85,
	   -28, -34, -1, 63, -5, -5, 39, 39,
	   -38, 32, -12, -28, 20, 40, -8, 2,
	   31, 12, -35, -13, 20, -25, 30, 8,
	   3, -13, -9, -20, 2, -13, 24, 37,
	   -10, 33, 6, 20, -16, -24, -6, -6,
	   -19, -5, 22, 21, 10, 11, -4, -39,
	   -1, 6, 49, 41, -15, -57, 21, -62,
	   77, -69, -13, 0, -74, 1, -7, -38,
	   -8, 6, 63, 28, 4, 26, -52, 82,
	   63, 13, 45, -33, 44, -52, -65, -21,
	   -46, -49, 64, -17, 32, 24, 68, -39,
	   -16, -5, -26, 28, 5, -61, -28, 2,
	   24, 11, -12, -33, 9, -37, -3, -28,
	   22, -37, -12, 19, 0, -18, -2, 14,
	   1, 4, 8, -9, -2, 43, -17, -2,
	   -66, -31, 56, -40, -87, -36, -2, -4,
	   -42, -45, -1, 31, -43, -15, 27, 63,
	   -11, 32, -10, -33, 27, -19, 4, 15,
	   -26, -34, 29, -4, -39, -65, 14, -20,
	   -21, -17, -36, 13, 59, 47, -38, -33,
	   13, -37, -8, -37, -7, -6, -76, -31,
	   -12, -46, 7, 24, -21, -30, -14, 9,
	   15, -12, -13, 47, -27, -25, -1, -39,
	   0, 20, -9, 6, 7, 4, 3, 7,
	   39, 50, 22, -7, 14, -20, 1, 70,
	   -28, 29, -41, 10, -16, -5, -28, -2,
	   -37, 32, -18, 17, 62, -11, -20, -50,
	   36, 21, -62, -12, -56, 52, 50, 17,
	   3, 48, 44, -41, -25, 3, 16, -3,
	   0, 33, -6, 15, 27, 34, -25, 22,
	   9, 17, -11, 36, 16, -2, 12, 21,
	   -52, 45, -2, -10, 46, 21, -18, 67,
	   -28, -13, 30, 37, 42, 16, -9, 11,
	   75, 7, -64, -40, -10, 29, 57, -23,
	   5, 53, -77, 3, -17, -5, 47, -55,
	   -35, -36, -13, 52, -53, -71, 52, -111,
	   -23, -26, -28, 29, -43, 55, -19, 43,
	   -19, 54, -12, -33, -44, -39, -19, -10,
	   -31, -10, 21, 38, -57, -20, 2, -25,
	   8, -6, 50, 12, 15, 25, -25, 15,
	   -30, -6, 9, 25, 37, 19, -4, 31,
	   -22, 2, 4, 2, 36, 7, 3, -34,
	   -80, 36, -10, -2, -5, 31, -36, 49,
	   -70, 20, -36, 21, 24, 25, -46, -51,
	   36, -58, -48, -40, -10, 55, 71, 47,
	   10, -1, 1, 2, -46, -68, 16, 13,
	   0, -74, -29, 73, -52, -18, -11, 7,
	   -44, -82, -32, -70, -28, -1, -39, -68,
	   -6, -41, 12, -22, -16, 40, -11, -25,
	   51, -9, 21, 4, 4, -34, 7, -78,
	   16, 6, -38, -30, -2, -44, 32, 0,
	   22, 64, 5, -72, -2, -14, -10, -16,
	   -8, -25, 12, 102, -58, 37, -10, -23,
	   15, 49, 7, -7, 2, -20, -32, 45,
	   -6, 48, 28, 30, 33, -1, 22, -6,
	   30, 65, -17, 29, 74, 37, -26, -10,
	   15, -24, 19, -66, 22, -10, -31, -1,
	   -18, -9, 11, 37, -4, 45, 5, 41,
	   17, 1, 1, 24, -58, 41, 5, -51,
	   14, 8, 43, 16, -10, -1, 45, 32,
	   -64, 3, -33, -25, -3, -27, -68, 12,
	   23, -11, -13, -37, -40, 4, -21, -12,
	   32, -23, -19, 76, 41, -23, -24, -44,
	   -65, -1, -15, 1, 71, 63, 5, 20,
	   -3, 21, -23, 31, -32, 18, -2, 27,
	   31, 46, -5, -39, -5, -35, 18, -18,
	   -40, -10, 3, 12, 2, -2, -22, 40,
	   5, -6, 60, 36, 3, 29, -27, 10,
	   25, -54, 5, 26, 39, 35, -24, -37,
	   30, -91, 28, -4, -21, -27, -39, -6,
	   5, 12, -128, 38, -16, 29, -95, -29,
	   82, -2, 35, 2, 12, 8, -22, 10,
	   80, -47, 2, -25, -73, -79, 16, -30,
	   -32, -66, 48, 21, -45, -11, -47, 14,
	   -27, -17, -7, 15, -44, -14, -44, -26,
	   -32, 26, -23, 17, -7, -28, 26, -6,
	   28, 6, -26, 2, 13, -14, -23, -14,
	   19, 46, 16, 2, -33, -21, 28, -17,
	   -42, 44, -37, 1, -39, 28, 84, -46,
	   15, 10, 13, -44, 72, -26, 26, 32,
	   -28, -12, -83, 2, 10, -30, -44, -10,
	   -28, 53, 45, 65, 0, -25, 57, 36,
	   -33, 6, 29, 44, -53, 11, 19, -2,
	   -27, 35, 32, 49, 4, 23, 38, 36,
	   24, 10, 51, -39, 4, -7, 26, 37,
	   -35, 11, -47, -18, 28, 16, -35, 42,
	   17, -21, -41, 28, 14, -12, 11, -45,
	   7, -43, -15, 18, -5, 38, -40, -50,
	   -30, -21, 9, -98, 13, 12, 23, 75,
	   -56, -7, -3, -4, -1, -34, 12, -49,
	   11, 26, -18, -28, -17, 33, 13, -14,
	   40, 24, -72, -37, 10, 17, -6, 22,
	   16, 16, -6, -12, -30, -14, 10, 40,
	   -23, 12, 15, -3, -15, 13, -56, -4,
	   -30, 1, -3, -17, 27, 50, -5, 64,
	   -36, -19, 7, 29, 22, 25, 9, -16,
	   -58, -69, -40, -61, -71, -14, 42, 93,
	   26, 11, -6, -58, -11, 70, -52, 19,
	   9, -30, -33, 11, -37, -47, -21, -22,
	   -40, 10, 47, 4, -23, 17, 48, 41,
	   -48, 14, 10, 15, 34, -23, -2, -47,
	   23, -32, -13, -10, -26, -26, -4, 16,
	   38, -14, 0, -12, -7, -7, 20, 44,
	   -1, -32, -27, -16, 4, -6, -18, 14,
	   5, 4, -29, 28, 7, -7, 15, -11,
	   -20, -45, -36, 16, 84, 34, -59, -30,
	   22, 126, 8, 68, 79, -17, 21, -68,
	   37, 5, 15, 63, 49, 127, -90, 85,
	   43, 7, 16, 9, 6, -45, -57, -43,
	   57, 11, -23, -11, -29, 60, -26, 0,
	   7, 42, -24, 10, 23, -25, 8, -7,
	   -40, 19, -17, 35, 4, 27, -39, -91,
	   27, -36, 34, 2, 16, -24, 25, 7,
	   -21, 5, 17, 10, -22, -30, 9, -17,
	   -61, -26, 33, 21, 58, -51, -14, 69,
	   -38, 20, 7, 80, -4, -65, -6, -27,
	   53, -12, 47, -1, -15, 1, 60, 102,
	   -79, -4, 12, 9, 22, 37, -8, -4,
	   37, 2, -3, -15, -16, -11, -5, 19,
	   -6, -43, 20, -25, -18, 10, -27, 0,
	   -28, -27, -11, 10, -18, -2, -4, -16,
	   26, 14, -6, 7, -6, 1, 53, -2,
	   -29, 23, 9, -30, -6, -4, -6, 56,
	   70, 0, -33, -20, -17, -9, -24, 46,
	   -5, -105, 47, -46, -51, 20, 20, -53,
	   -81, -1, -7, 75, -5, -21, -65, 12,
	   -52, 22, -50, -12, 49, 54, 76, -81,
	   10, 45, -41, -59, 18, -19, 25, 14,
	   -31, -53, -5, 12, 31, 84, -23, 2,
	   7, 2, 10, -32, 39, -2, -12, 1,
	   -9, 0, -10, -11, 9, 15, -8, -2,
	   2, -1, 10, 14, -5, -40, 19, -7,
	   -7, 26, -4, 2, 1, -27, 35, 32,
	   21, -31, 26, 43, -9, 4, -32, 40,
	   -62, -52, 36, 22, 38, 22, 36, -96,
	   6, -10, -23, -49, 15, -33, -18, -3,
	   0, 41, 21, -19, 21, 23, -39, -23,
	   -6, 6, 47, 56, 4, 74, 0, -98,
	   29, -47, -14, -36, 21, -22, 22, 16,
	   13, 12, 16, -5, 13, 17, -13, -15,
	   1, -34, -26, 26, 12, 32, 27, 13,
	   -67, 27, 2, 8, 10, 18, 16, 20,
	   -17, -17, 57, -64, 5, 14, 19, 31,
	   -18, -44, -46, -16, 4, -25, 17, -126,
	   -24, 39, 4, 8, 55, -25, -34, 39,
	   -16, 3, 9, 71, 72, -31, -55, 6,
	   10, -25, 32, -85, -21, 18, -8, 15,
	   12, -27, -7, 1, -21, -2, -5, 48,
	   -16, 18, 1, -22, -26, 16, 14, -31,
	   27, -6, -15, -21, 4, -14, 18, -36
	};

	private static final byte layer1_recur_weights[] = {// [1728] = {
	   20, 67, -99, 12, 41, -25, 49, -44,
	   35, 81, 110, 47, 34, -66, -14, 14,
	   -60, 34, 29, -73, 10, 41, 35, 89,
	   7, -35, 22, 7, 27, -20, -6, 56,
	   26, 66, 6, 33, -55, 53, 1, -21,
	   14, 17, 68, 55, 59, 0, 18, -9,
	   5, -41, 6, -5, -114, -12, 29, 42,
	   -23, 10, 81, -27, 20, -53, -30, -62,
	   40, 95, 25, -4, 3, 18, -8, -15,
	   -29, -82, 2, -57, -3, -61, -29, -29,
	   49, 2, -55, 5, -69, -99, -49, -51,
	   6, -25, 12, 89, 44, -33, 5, 41,
	   1, 23, -37, -37, -28, -48, 3, 4,
	   -41, -30, -57, -35, -39, -1, -13, -56,
	   -5, 50, 49, 41, -4, -4, 33, -22,
	   -1, 33, 34, 18, 40, -42, 12, 1,
	   -6, -2, 18, 17, 39, 44, 11, 65,
	   -60, -45, 10, 91, 21, 9, -62, -11,
	   8, 69, 37, 24, -30, 21, 26, -27,
	   1, -28, 24, 66, -8, 6, -71, 34,
	   24, 44, 58, -78, -19, 57, 17, -60,
	   1, 12, -3, -1, -40, 22, 11, -5,
	   25, 12, 1, 72, 79, 7, -50, 23,
	   18, 13, 21, -11, -20, 5, 77, -94,
	   24, 15, 57, -51, 3, 36, 53, -1,
	   4, 14, 30, -31, 22, 40, 32, -11,
	   -34, -36, -59, 58, 25, 21, -54, -23,
	   40, 46, 18, 0, 12, 54, -96, -99,
	   -59, 5, 119, -38, 50, 55, 12, -16,
	   67, 0, 34, 35, 39, 35, -1, 69,
	   24, 27, -30, -35, -4, -70, 2, -44,
	   -7, -6, 19, -9, 60, 44, -21, -10,
	   37, 43, -16, -3, 30, -15, -65, 31,
	   -55, 18, -98, 76, 64, 25, 24, -18,
	   -7, -68, -10, 38, 27, -60, 36, 33,
	   16, 30, 34, -39, -37, 31, 12, 53,
	   -54, 14, -26, -49, -128, -13, -5, -22,
	   -11, -85, 55, -8, -51, -11, -33, -10,
	   -31, -76, -41, 23, 44, -40, -54, -127,
	   -101, 19, -23, -15, 15, 27, 58, -60,
	   8, 14, -33, 1, 48, -9, -11, -123,
	   3, 53, 23, 4, -28, 22, 2, -29,
	   -67, 36, 12, 7, 55, -21, 88, 20,
	   -1, -21, -17, 3, 41, 32, -10, -14,
	   -5, -57, 67, 57, 21, 23, -2, -27,
	   -73, -24, 120, 21, 18, -35, 42, -7,
	   3, -45, -25, 76, -34, 50, 11, -54,
	   -91, 3, -113, -20, -5, 47, 15, -47,
	   17, 27, -3, -26, -7, 10, 7, 74,
	   -40, 64, -7, -5, -24, -49, -24, -3,
	   -10, 27, -17, -8, -3, 14, -27, 33,
	   13, 39, 28, -7, -38, 29, 16, 44,
	   19, 55, -3, 9, -13, -57, 43, 43,
	   31, 0, -93, -17, 19, -56, 4, -12,
	   -25, 37, -85, -13, -118, 33, -17, 56,
	   71, -80, -4, 6, -11, -18, 47, -52,
	   25, 9, 48, -107, 1, 21, 20, -3,
	   10, -16, -4, 24, 17, 31, -61, -18,
	   -50, 24, -10, 12, 71, 26, 11, -3,
	   4, 1, 0, -7, -40, 18, 38, -34,
	   38, 17, 8, -34, 2, 21, 123, -32,
	   -26, 43, 14, -34, -1, -9, 37, -16,
	   6, -17, -62, 68, 22, 17, 11, -75,
	   33, -80, 62, -9, -75, 76, 36, -41,
	   -8, -40, -11, -71, 40, -39, 62, -49,
	   -81, 16, -9, -52, 52, 61, 17, -103,
	   -27, -10, -8, -54, -57, 21, 23, -16,
	   -52, 36, 18, 10, -5, 8, 15, -29,
	   5, -19, -37, 8, -53, 6, 19, -37,
	   38, -17, 48, 10, 0, 81, 46, 70,
	   -29, 101, 11, 44, -44, -3, 24, 11,
	   3, 14, -9, 11, 14, -45, 13, 46,
	   -3, -57, 68, 44, 63, 98, 25, -28,
	   -23, 15, 32, -10, 53, -6, -2, -9,
	   -6, 16, -107, -11, -11, -28, 59, 57,
	   -22, 38, 42, 83, 27, 5, 29, -30,
	   12, -21, -13, 31, 38, -21, 58, -10,
	   -10, -15, -2, -5, 11, 12, -73, -28,
	   -38, 22, 2, -25, 73, -52, -12, -55,
	   32, -63, 21, 51, 33, 52, -26, 55,
	   -26, -26, 57, -32, -4, -52, -61, 21,
	   -33, -91, -51, 69, -90, -53, -38, -44,
	   12, -76, -20, 77, -45, -7, 86, 43,
	   -109, -33, -105, -40, -121, -10, 0, -72,
	   45, -51, -75, -49, -38, -1, -62, 18,
	   -1, 30, -44, -14, -10, -67, 40, -10,
	   -34, 46, -64, -32, 29, -13, 33, 3,
	   -32, -5, 28, -27, -25, 93, 24, 68,
	   -40, 57, 23, -3, -21, -58, 17, -39,
	   -17, -22, -89, 11, 18, -46, 27, 24,
	   46, 127, 61, 87, 31, 127, -36, 47,
	   -23, 47, 127, -24, 110, 122, 30, 100,
	   0, 96, -12, 6, 50, 44, -13, 73,
	   4, 55, -11, -15, 49, 42, -6, 20,
	   -35, 58, 18, 38, 42, 72, 19, -21,
	   11, 9, -37, 7, 29, 31, 16, -17,
	   13, -50, 19, 5, -23, 51, -16, -5,
	   4, -24, 76, 10, -53, -28, -7, -65,
	   74, 40, -16, -29, 32, -16, -49, -35,
	   -3, 59, -96, -50, -43, -43, -61, -15,
	   -8, -36, -34, -33, -14, 11, -3, -39,
	   4, -114, -123, -11, -49, -21, 14, -56,
	   1, 43, -63, 26, 40, 18, -10, -26,
	   -14, -15, -35, -35, -11, 32, -44, -67,
	   2, 22, 7, 3, -9, -30, -51, -28,
	   28, 6, -22, 16, 34, -25, -52, -54,
	   -8, -6, 5, 8, 20, -16, -17, -44,
	   27, 3, 31, -5, -48, -1, -3, 116,
	   11, 71, -31, -47, 109, 50, -22, -12,
	   -57, 32, 66, 8, -25, -93, -54, -10,
	   19, -76, -34, 97, 48, -36, -18, -30,
	   -39, -26, -12, 28, 14, 12, -12, -31,
	   38, 2, 10, 4, -40, 20, 16, -61,
	   2, 64, 39, 5, 15, 33, 40, -61,
	   -49, 93, -10, 33, 28, -11, -27, -18,
	   39, -62, -6, -6, 62, 11, -8, 38,
	   -67, 12, 27, 39, -27, 123, -18, -6,
	   -65, 83, -64, 20, 19, -11, 33, 24,
	   17, 56, 78, 7, -15, 54, -101, -9,
	   115, -96, 50, 51, 35, 34, 27, 37,
	   -40, -11, 8, -36, 42, -45, 2, -23,
	   0, 67, -8, -9, -13, 50, -14, -27,
	   4, 0, -8, -14, 30, -9, 29, 15,
	   9, -38, 37, -8, 50, -46, 54, 41,
	   -11, -8, -11, -26, 39, 45, 14, -26,
	   -17, -27, 69, 38, 39, 98, 66, 0,
	   42, 123, -101, -19, -83, 117, -32, 56,
	   10, 12, -88, 79, -53, 56, 63, 95,
	   -62, 9, 36, -13, -79, -16, 37, -46,
	   35, -34, 14, 17, -54, 5, 21, -7,
	   7, 63, 56, 15, 27, -76, -25, 4,
	   -26, -63, 28, -67, -52, 43, -47, -70,
	   40, -12, 40, -66, -37, 0, 35, 37,
	   -53, 4, -17, -51, 11, 21, 14, -34,
	   -4, 24, -42, 29, 22, 7, 28, 12,
	   37, 39, -39, -19, 65, -60, -50, -2,
	   1, 82, 39, 19, -23, -43, -22, -67,
	   -35, -34, 32, 102, 81, 127, 36, 67,
	   -45, 1, -67, -52, -4, 35, 20, 28,
	   71, 86, -35, -9, -83, -34, 12, 9,
	   -23, 2, 14, 28, -23, 7, -25, 45,
	   7, 17, -37, 0, -19, 31, 26, 40,
	   -27, -16, 17, 5, -21, 23, 24, 96,
	   -55, 52, -19, -14, -6, 1, 50, -34,
	   86, -53, 38, 2, -52, -36, -13, 60,
	   -85, -120, 32, 7, -12, 22, 70, -7,
	   -94, 38, -76, -31, -20, 15, -28, 7,
	   6, 40, 53, 88, 3, 38, 18, -8,
	   -22, -23, 51, 37, -9, 13, -32, 25,
	   -21, 27, 31, 20, 18, -9, -13, 1,
	   21, -24, -13, 39, 15, -11, -29, -36,
	   18, 15, 8, 27, 21, -94, -1, -22,
	   49, 66, -1, 6, -3, -40, -18, 6,
	   28, 12, 33, -59, 62, 60, -48, 90,
	   -1, 108, 9, 18, -2, 27, 77, -65,
	   82, -48, -38, -19, -11, 127, 50, 66,
	   18, -13, -22, 60, -38, 40, -14, -26,
	   -13, 38, 67, 57, 30, 33, 26, 36,
	   38, -17, 27, -28, 20, 12, -64, 18,
	   5, -33, -27, 13, -26, 32, 35, -5,
	   -48, -14, 92, 43, -47, -14, 40, 11,
	   51, 66, 22, -63, -16, -61, 4, -28,
	   27, 20, -33, -30, -21, -29, -53, 31,
	   -40, 24, 43, -4, -19, 21, 67, 20,
	   100, -16, -93, 78, -6, -18, -52, -37,
	   -9, 66, -31, -8, 26, 18, 4, 24,
	   -22, 17, -2, -13, 27, 0, 8, -18,
	   -25, 5, -21, -24, -7, 18, -93, 21,
	   7, 2, -75, 69, 50, -5, -15, -17,
	   60, -42, 55, 1, -4, 3, 10, 46,
	   16, -13, 45, -7, -10, -44, -108, 49,
	   2, -15, -64, -12, -72, 32, -38, -45,
	   10, -54, 13, -13, -27, -36, -64, 58,
	   -62, -101, 88, -86, -71, -39, -9, -128,
	   32, 15, -4, 54, -16, -39, -26, -36,
	   46, 48, -64, -10, 19, 30, -13, 34,
	   -8, 50, 60, -22, -6, -11, -30, 5,
	   50, 32, 56, 0, 25, 6, 68, 11,
	   -29, 45, -9, -12, 4, 1, 18, -49,
	   0, -38, -19, 90, 29, 35, 51, 8,
	   -48, 96, -1, -12, -9, -32, -63, -65,
	   -7, 38, 89, 28, -85, -28, -23, -25,
	   -128, 56, 79, -36, 99, -6, -37, 7,
	   -13, -69, -46, -29, 25, 64, -21, 17,
	   1, 42, -66, 1, 80, 26, -32, 21,
	   15, 15, 6, 6, -10, 15, 127, 5,
	   38, 27, 87, -57, -25, 11, 72, -21,
	   -5, 11, -13, -66, 78, 36, -3, 41,
	   -21, 8, -33, 23, 73, 28, 57, -25,
	   -5, 4, -22, -47, 15, 4, -57, -72,
	   33, 1, 18, 2, 53, -71, -99, -21,
	   -3, -111, 108, 71, -14, 82, 25, 61,
	   -48, 5, 9, -51, -20, -25, -3, 14,
	   -33, 14, -3, -34, 22, 12, -19, -38,
	   -16, 2, 21, 16, 26, -31, 75, 44,
	   -31, 16, 26, 66, 17, -9, -22, -22,
	   22, -44, 22, 27, 2, 58, -14, 10,
	   -73, -42, 55, -25, -61, 72, -1, 30,
	   -58, -25, 63, 26, -48, -40, 26, -30,
	   60, 8, -17, -1, -18, -20, 43, -20,
	   -4, -28, 127, -106, 29, 70, 64, -27,
	   39, -33, -5, -88, -40, -52, 26, 44,
	   -17, 23, 2, -49, 22, -9, -8, 86,
	   49, -43, -60, 1, 10, 45, 36, -53,
	   -4, 33, 38, 48, -72, 1, 19, 21,
	   -65, 4, -5, -62, 27, -25, 17, -6,
	   6, -45, -39, -46, 4, 26, 127, -9,
	   18, -33, -18, -3, 33, 2, -5, 15,
	   -26, -22, -117, -63, -17, -59, 61, -74,
	   7, -47, -58, -128, -67, 15, -16, -128,
	   12, 2, 20, 9, -48, -40, 43, 3,
	   -40, -16, -38, -6, -22, -28, -16, -59,
	   -22, 6, -5, 11, -12, -66, -40, 27,
	   -62, -44, -19, 38, -3, 39, -8, 40,
	   -24, 13, 21, 50, -60, -22, 53, -29,
	   -6, 1, 22, -59, 0, 17, -39, 115
	};

	private static final byte layer1_bias[] = {// [72] = {
	   -42, 20, 16, 0, 105, 60, 1, -97,
	   24, 60, 18, 13, 62, 25, 127, 34,
	   79, 55, 118, 127, 95, 31, -4, 87,
	   21, 12, 2, -14, 18, 23, 8, 17,
	   -1, -8, 5, 4, 24, 37, 21, 13,
	   36, 13, 17, 18, 37, 30, 33, 1,
	   8, -16, -11, -5, -31, -3, -5, 0,
	   6, 3, 58, -7, -1, -16, 5, -13,
	   16, 10, -2, -14, 11, -4, 3, -11
	};

	private static final byte layer2_weights[] = {// [48] = {
	   -113, -88, 31, -128, -126, -61, 85, -35,
	   118, -128, -61, 127, -128, -17, -128, 127,
	   104, -9, -128, 33, 45, 127, 5, 83,
	   84, -128, -85, -128, -45, 48, -53, -128,
	   46, 127, -17, 125, 117, -41, -117, -91,
	   -127, -68, -1, -89, -80, 32, 106, 7
	};

	private static final byte layer2_bias[] = {// [2] = {
			14, 117
	};

	private static final JDenseLayer layer0 = new JDenseLayer(
			layer0_bias,
			layer0_weights,
			25, 32, false
		);

	private static final JGRULayer layer1 = new JGRULayer(
			layer1_bias,
			layer1_weights,
			layer1_recur_weights,
			32, 24
		);

	private static final JDenseLayer layer2 = new JDenseLayer(
			layer2_bias,
			layer2_weights,
			24, 2, true
		);

	//
// typedef struct {
	// int arch;
	int application;
	private int Fs;
	// #define TONALITY_ANALYSIS_RESET_START angle
	private final float angle[] = new float[240];
	private final float d_angle[] = new float[240];
	private final float d2_angle[] = new float[240];
	private final float inmem[] = new float[ANALYSIS_BUF_SIZE];
	/** number of usable samples in the buffer */
	private int mem_fill;
	private final float prev_band_tonality[] = new float[NB_TBANDS];
	private float prev_tonality;
	private int prev_bandwidth;
	private final float E[][] = new float[NB_FRAMES][NB_TBANDS];
	private final float logE[][] = new float[NB_FRAMES][NB_TBANDS];
	private final float lowE[] = new float[NB_TBANDS];
	private final float highE[] = new float[NB_TBANDS];
	private final float meanE[] = new float[NB_TBANDS + 1];
	private final float mem[] = new float[32];
	private final float cmean[] = new float[8];
	private final float std[] = new float[9];
	private float Etracker;
	private float lowECount;
	private int E_count;
	private int count;
	private int analysis_offset;
	private int write_pos;
	int read_pos;
	int read_subframe;
	private float hp_ener_accum;
	private final float rnn_state[] = new float[Jmlp.MAX_NEURONS];
	private final float downmix_state[] = new float[3];
	private final JAnalysisInfo info[] = new JAnalysisInfo[DETECT_SIZE];
	//
	JTonalityAnalysisState() {
		for( int i = 0; i < DETECT_SIZE; i++ ) {
			info[i] = new JAnalysisInfo();
		}
	}
	final void clear(final boolean isFull) {
		if( isFull ) {
			// arch = 0;
			application = 0;
			Fs = 0;
		}
		float[] fbuff = angle;
		int i = 240;
		do {
			fbuff[--i] = 0;
		} while( i > 0 );
		fbuff = d_angle;
		i = 240;
		do {
			fbuff[--i] = 0;
		} while( i > 0 );
		fbuff = d2_angle;
		i = 240;
		do {
			fbuff[--i] = 0;
		} while( i > 0 );
		fbuff = inmem;
		i = ANALYSIS_BUF_SIZE;
		do {
			fbuff[--i] = 0;
		} while( i > 0 );
		mem_fill = 0;
		fbuff = prev_band_tonality;
		i = NB_TBANDS;
		do {
			fbuff[--i] = 0;
		} while( i > 0 );
		prev_tonality = 0;
		prev_bandwidth = 0;
		int j = NB_FRAMES;
		do {
			fbuff = E[--j];
			i = NB_TBANDS;
			do {
				fbuff[--i] = 0;
			} while( i > 0 );
		} while( j > 0 );
		j = NB_FRAMES;
		do {
			fbuff = logE[--j];
			i = NB_TBANDS;
			do {
				fbuff[--i] = 0;
			} while( i > 0 );
		} while( j > 0 );
		fbuff = lowE;
		i = NB_TBANDS;
		do {
			fbuff[--i] = 0;
		} while( i > 0 );
		fbuff = highE;
		i = NB_TBANDS;
		do {
			fbuff[--i] = 0;
		} while( i > 0 );
		fbuff = meanE;
		i = NB_TBANDS + 1;
		do {
			fbuff[--i] = 0;
		} while( i > 0 );
		fbuff = mem;
		i = 32;
		do {
			fbuff[--i] = 0;
		} while( i > 0 );
		fbuff = cmean;
		i = 8;
		do {
			fbuff[--i] = 0;
		} while( i > 0 );
		fbuff = std;
		i = 9;
		do {
			fbuff[--i] = 0;
		} while( i > 0 );
		Etracker = 0;
		lowECount = 0;
		E_count = 0;
		count = 0;
		analysis_offset = 0;
		write_pos = 0;
		read_pos = 0;
		read_subframe = 0;
		hp_ener_accum = 0;
		i = Jmlp.MAX_NEURONS;
		do {
			i--;
			rnn_state[i] = 0;
		} while( i > 0 );
		downmix_state[0] = 0; downmix_state[1] = 0; downmix_state[2] = 0;
		i = DETECT_SIZE;
		do {
			info[--i].clear();
		} while( i > 0 );
	}
	final void copyFrom(final JTonalityAnalysisState t) {
		// arch = t.arch;
		application = t.application;
		Fs = t.Fs;
		System.arraycopy( t.angle, 0, angle, 0, 240 );
		System.arraycopy( t.d_angle, 0, d_angle, 0, 240 );
		System.arraycopy( t.d2_angle, 0, d2_angle, 0, 240 );
		System.arraycopy( t.inmem, 0, inmem, 0, ANALYSIS_BUF_SIZE );
		mem_fill = t.mem_fill;
		System.arraycopy( t.prev_band_tonality, 0, prev_band_tonality, 0, NB_TBANDS );
		prev_tonality = t.prev_tonality;
		prev_bandwidth = t.prev_bandwidth;
		int i = NB_FRAMES;
		do {
			final float[] fbuf = E[--i];
			final float[] sfbuf = t.E[i];
			System.arraycopy( sfbuf, 0, fbuf, 0, NB_TBANDS );
		} while( i > 0 );
		i = NB_FRAMES;
		do {
			final float[] fbuf = logE[--i];
			final float[] sfbuf = t.logE[i];
			System.arraycopy( sfbuf, 0, fbuf, 0, NB_TBANDS );
		} while( i > 0 );
		System.arraycopy( t.lowE, 0, lowE, 0, NB_TBANDS );
		System.arraycopy( t.highE, 0, highE, 0, NB_TBANDS );
		System.arraycopy( t.meanE, 0, meanE, 0, NB_TBANDS + 1 );
		System.arraycopy( t.mem, 0, mem, 0, 32 );
		System.arraycopy( t.cmean, 0, cmean, 0, 8 );
		System.arraycopy( t.std, 0, std, 0, 9 );
		Etracker = t.Etracker;
		lowECount = t.lowECount;
		E_count = t.E_count;
		count = t.count;
		analysis_offset = t.analysis_offset;
		write_pos = t.write_pos;
		read_pos = t.read_pos;
		read_subframe = t.read_subframe;
		hp_ener_accum = t.hp_ener_accum;
		System.arraycopy( t.rnn_state, 0, rnn_state, 0, Jmlp.MAX_NEURONS );
		downmix_state[0] = t.downmix_state[0]; downmix_state[1] = t.downmix_state[1]; downmix_state[2] = t.downmix_state[2];
		i = DETECT_SIZE;
		do {
			i--;
			info[i].copyFrom( t.info[i] );
		} while( i > 0 );
	}
//} TonalityAnalysisState;
// #ifndef DISABLE_FLOAT_API

	private static final int TRANSITION_PENALTY = 10;

	private static final float dct_table[/* 128 */] = {
		0.250000f, 0.250000f, 0.250000f, 0.250000f, 0.250000f, 0.250000f, 0.250000f, 0.250000f,
		0.250000f, 0.250000f, 0.250000f, 0.250000f, 0.250000f, 0.250000f, 0.250000f, 0.250000f,
		0.351851f, 0.338330f, 0.311806f, 0.273300f, 0.224292f, 0.166664f, 0.102631f, 0.034654f,
		-0.034654f,-0.102631f,-0.166664f,-0.224292f,-0.273300f,-0.311806f,-0.338330f,-0.351851f,
		0.346760f, 0.293969f, 0.196424f, 0.068975f,-0.068975f,-0.196424f,-0.293969f,-0.346760f,
		-0.346760f,-0.293969f,-0.196424f,-0.068975f, 0.068975f, 0.196424f, 0.293969f, 0.346760f,
		0.338330f, 0.224292f, 0.034654f,-0.166664f,-0.311806f,-0.351851f,-0.273300f,-0.102631f,
		0.102631f, 0.273300f, 0.351851f, 0.311806f, 0.166664f,-0.034654f,-0.224292f,-0.338330f,
		0.326641f, 0.135299f,-0.135299f,-0.326641f,-0.326641f,-0.135299f, 0.135299f, 0.326641f,
		0.326641f, 0.135299f,-0.135299f,-0.326641f,-0.326641f,-0.135299f, 0.135299f, 0.326641f,
		0.311806f, 0.034654f,-0.273300f,-0.338330f,-0.102631f, 0.224292f, 0.351851f, 0.166664f,
		-0.166664f,-0.351851f,-0.224292f, 0.102631f, 0.338330f, 0.273300f,-0.034654f,-0.311806f,
		0.293969f,-0.068975f,-0.346760f,-0.196424f, 0.196424f, 0.346760f, 0.068975f,-0.293969f,
		-0.293969f, 0.068975f, 0.346760f, 0.196424f,-0.196424f,-0.346760f,-0.068975f, 0.293969f,
		0.273300f,-0.166664f,-0.338330f, 0.034654f, 0.351851f, 0.102631f,-0.311806f,-0.224292f,
		0.224292f, 0.311806f,-0.102631f,-0.351851f,-0.034654f, 0.338330f, 0.166664f,-0.273300f,
	};

	private static final float analysis_window[/* 240 */] = {
		0.000043f, 0.000171f, 0.000385f, 0.000685f, 0.001071f, 0.001541f, 0.002098f, 0.002739f,
		0.003466f, 0.004278f, 0.005174f, 0.006156f, 0.007222f, 0.008373f, 0.009607f, 0.010926f,
		0.012329f, 0.013815f, 0.015385f, 0.017037f, 0.018772f, 0.020590f, 0.022490f, 0.024472f,
		0.026535f, 0.028679f, 0.030904f, 0.033210f, 0.035595f, 0.038060f, 0.040604f, 0.043227f,
		0.045928f, 0.048707f, 0.051564f, 0.054497f, 0.057506f, 0.060591f, 0.063752f, 0.066987f,
		0.070297f, 0.073680f, 0.077136f, 0.080665f, 0.084265f, 0.087937f, 0.091679f, 0.095492f,
		0.099373f, 0.103323f, 0.107342f, 0.111427f, 0.115579f, 0.119797f, 0.124080f, 0.128428f,
		0.132839f, 0.137313f, 0.141849f, 0.146447f, 0.151105f, 0.155823f, 0.160600f, 0.165435f,
		0.170327f, 0.175276f, 0.180280f, 0.185340f, 0.190453f, 0.195619f, 0.200838f, 0.206107f,
		0.211427f, 0.216797f, 0.222215f, 0.227680f, 0.233193f, 0.238751f, 0.244353f, 0.250000f,
		0.255689f, 0.261421f, 0.267193f, 0.273005f, 0.278856f, 0.284744f, 0.290670f, 0.296632f,
		0.302628f, 0.308658f, 0.314721f, 0.320816f, 0.326941f, 0.333097f, 0.339280f, 0.345492f,
		0.351729f, 0.357992f, 0.364280f, 0.370590f, 0.376923f, 0.383277f, 0.389651f, 0.396044f,
		0.402455f, 0.408882f, 0.415325f, 0.421783f, 0.428254f, 0.434737f, 0.441231f, 0.447736f,
		0.454249f, 0.460770f, 0.467298f, 0.473832f, 0.480370f, 0.486912f, 0.493455f, 0.500000f,
		0.506545f, 0.513088f, 0.519630f, 0.526168f, 0.532702f, 0.539230f, 0.545751f, 0.552264f,
		0.558769f, 0.565263f, 0.571746f, 0.578217f, 0.584675f, 0.591118f, 0.597545f, 0.603956f,
		0.610349f, 0.616723f, 0.623077f, 0.629410f, 0.635720f, 0.642008f, 0.648271f, 0.654508f,
		0.660720f, 0.666903f, 0.673059f, 0.679184f, 0.685279f, 0.691342f, 0.697372f, 0.703368f,
		0.709330f, 0.715256f, 0.721144f, 0.726995f, 0.732807f, 0.738579f, 0.744311f, 0.750000f,
		0.755647f, 0.761249f, 0.766807f, 0.772320f, 0.777785f, 0.783203f, 0.788573f, 0.793893f,
		0.799162f, 0.804381f, 0.809547f, 0.814660f, 0.819720f, 0.824724f, 0.829673f, 0.834565f,
		0.839400f, 0.844177f, 0.848895f, 0.853553f, 0.858151f, 0.862687f, 0.867161f, 0.871572f,
		0.875920f, 0.880203f, 0.884421f, 0.888573f, 0.892658f, 0.896677f, 0.900627f, 0.904508f,
		0.908321f, 0.912063f, 0.915735f, 0.919335f, 0.922864f, 0.926320f, 0.929703f, 0.933013f,
		0.936248f, 0.939409f, 0.942494f, 0.945503f, 0.948436f, 0.951293f, 0.954072f, 0.956773f,
		0.959396f, 0.961940f, 0.964405f, 0.966790f, 0.969096f, 0.971321f, 0.973465f, 0.975528f,
		0.977510f, 0.979410f, 0.981228f, 0.982963f, 0.984615f, 0.986185f, 0.987671f, 0.989074f,
		0.990393f, 0.991627f, 0.992778f, 0.993844f, 0.994826f, 0.995722f, 0.996534f, 0.997261f,
		0.997902f, 0.998459f, 0.998929f, 0.999315f, 0.999615f, 0.999829f, 0.999957f, 1.000000f,
	};

	private static final int tbands[/* NB_TBANDS + 1 */] = {
		4, 8, 12, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 136, 160, 192, 240
	};

	private static final int NB_TONAL_SKIP_BANDS = 9;

	/**
	 *
	 * @param S I/O  State vector [ 2 ]
	 * @param out O    Output signal [ floor(len/2) ]
	 * @param in I    Input signal [ len ]
	 * @param inLen I    Number of input samples
	 * @return
	 */
	private static final float silk_resampler_down2_hp(final float[] S, final float[] out, final float[] in, final int inLen)
	{
		final int len2 = inLen >> 1;
		float hp_ener = 0;
		/* Internal variables and state are in Q10 format */
		// java vars
		float s0 = S[0];
		float s1 = S[1];
		float s2 = S[2];
		for( int k = 0, k2 = 0; k < len2; k++ ) {
			/* Convert to Q10 */
			float in32 = in[ k2++ ];

			/* All-pass section for even input sample */
			float Y      = ( in32 - s0 );
			float X      = 0.6074371f * Y;
			float out32  = ( s0 + X );
			s0 = ( in32 + X );
			float out32_hp = out32;
			/* Convert to Q10 */
			in32 = in[ k2++ ];

			/* All-pass section for odd input sample, and add to output of previous section */
			Y      = ( in32 - s1 );
			X      = 0.15063f * Y;
			out32  += s1;
			out32  += X;
			s1 = ( in32 + X );

			Y      = ( -in32 - s2 );
			X      = 0.15063f * Y;
			out32_hp  += s2;
			out32_hp  += X;
			s2 = ( -in32 + X );

			hp_ener += out32_hp * out32_hp;
			/* Add, convert back to int16 and store to output */
			out[ k ] = 0.5f * out32;
		}
		S[0] = s0;
		S[1] = s1;
		S[2] = s2;
// #ifdef FIXED_POINT
		/* len2 can be up to 480, so we shift by 8 more to make it fit. */
//		hp_ener = hp_ener >> (2*SIG_SHIFT + 8);
// #endif
		return hp_ener;
	}

	private static final float downmix_and_resample(final Idownmix/*downmix_func*/ downmix,
			final Object _x, final int xoffset,// java
			final float[] y, final int yoffset,// java
			final float S[/* 3 */], int subframe, int offset, final int c1, final int c2, final int C, final int Fs)
	{
		float ret = 0;
		// SAVE_STACK;

		if( subframe == 0 ) {
			return 0;
		}
		if( Fs == 48000 )
		{
			subframe <<= 1;
			offset <<= 1;
		} else if( Fs == 16000 ) {
			subframe = (subframe << 1) / 3;
			offset = (offset << 1) / 3;
		}
		final float[] tmp = new float[ subframe ];

		downmix.downmix( _x, xoffset, tmp, 0, subframe, offset, c1, c2, C );
/* #ifdef FIXED_POINT
		scale = (1<<SIG_SHIFT);
#else */
		float scale = 1.f / 32768;
// #endif
		if( c2 == -2 ) {
			scale /= C;
		} else if( c2 > -1 ) {
			scale /= 2;
		}
		for( int j = 0; j < subframe; j++ ) {
			tmp[j] *= scale;
		}
		if( Fs == 48000 )
		{
			ret = silk_resampler_down2_hp( S, y, tmp, subframe );
		} else if( Fs == 24000 ) {
			System.arraycopy( tmp, 0, y, 0, subframe );
		} else if( Fs == 16000 ) {
			final float[] tmp3x = new float[ 3 * subframe ];
			/* Don't do this at home! This resampler is horrible and it's only (barely)
			  usable for the purpose of the analysis because we don't care about all
			  the aliasing between 8 kHz and 12 kHz. */
			for( int j = 0, j3 = 0; j < subframe; j++ )
			{
				final float v = tmp[j];// java
				tmp3x[j3++] = v;
				tmp3x[j3++] = v;
				tmp3x[j3++] = v;
			}
			silk_resampler_down2_hp( S, y, tmp3x, tmp3x.length /* 3 * subframe */ );
		}
		// RESTORE_STACK;
		return ret;
	}

	/** Initialize a TonalityAnalysisState struct.
	 *
	 * This performs some possibly slow initialization steps which should
	 * not be repeated every analysis step. No allocated memory is retained
	 * by the state struct, so no cleanup call is required.
	 *
	 * @param iFs frequency
	 */
	final void tonality_analysis_init(final int iFs)
	{
		/* Initialize reusable fields. */
		// tonal.arch = opus_select_arch();
		this.Fs = iFs;
		/* Clear remaining fields. */
		tonality_analysis_reset();
	}

	/** Reset a TonalityAnalysisState stuct.
	 *
	 * Call this when there's a discontinuity in the data.
	 */
	final void tonality_analysis_reset()
	{
		/* Clear non-reusable fields. */
		// final char *start = (char*)&tonal.TONALITY_ANALYSIS_RESET_START;
		// OPUS_CLEAR( start, sizeof( JTonalityAnalysisState ) - (start - (char*)tonal) );
		clear( false );
	}

	private final void tonality_get_info(final JAnalysisInfo info_out, final int len)
	{
		int pos = this.read_pos;
		int curr_lookahead = this.write_pos - this.read_pos;
		if( curr_lookahead < 0 ) {
			curr_lookahead += DETECT_SIZE;
		}

		/* On long frames, look at the second analysis window rather than the first. */
		if( len > this.Fs / 50 && pos != this.write_pos )
		{
			pos++;
			if( pos == DETECT_SIZE ) {
				pos = 0;
			}
		}
		if( pos == this.write_pos ) {
			pos--;
		}
		if( pos < 0 ) {
			pos = DETECT_SIZE - 1;
		}
		final int pos0 = pos;
		info_out.copyFrom( this.info[pos] );

		float tonality_max, tonality_avg;
		tonality_max = tonality_avg = info_out.tonality;
		int tonality_count = 1;
		/* Look at the neighbouring frames and pick largest bandwidth found (to be safe). */
		int bandwidth_span = 6;
		final JAnalysisInfo[] this_info = this.info;// java
		/* If possible, look ahead for a tone to compensate for the delay in the tone detector. */
		for( int i = 0; i < 3; i++ )
		{
			pos++;
			if( pos == DETECT_SIZE ) {
				pos = 0;
			}
			if( pos == this.write_pos ) {
				break;
			}
			final JAnalysisInfo info_pos = this_info[pos];// java
			final float v = info_pos.tonality;// java
			tonality_max = (tonality_max > v ? tonality_max : v);
			tonality_avg += v;// java this.info[pos].tonality;
			tonality_count++;
			if( info_out.bandwidth < info_pos.bandwidth ) {
				info_out.bandwidth = info_pos.bandwidth;
			}
			bandwidth_span--;
		}
		pos = pos0;
		/* Look back in time to see if any has a wider bandwidth than the current frame. */
		for( int i = 0; i < bandwidth_span; i++ )
		{
			pos--;
			if( pos < 0 ) {
				pos = DETECT_SIZE - 1;
			}
			if( pos == this.write_pos ) {
				break;
			}
			if( info_out.bandwidth < this_info[pos].bandwidth ) {
				info_out.bandwidth = this_info[pos].bandwidth;
			}
		}
		tonality_avg /= tonality_count;// java
		tonality_max -= .2f;// java
		info_out.tonality = (tonality_avg > tonality_max ? tonality_avg : tonality_max);

		int mpos, vpos;
		mpos = vpos = pos0;
		/* If we have enough look-ahead, compensate for the ~5-frame delay in the music prob and
		   ~1 frame delay in the VAD prob. */
		if( curr_lookahead > 15 )
		{
			mpos += 5;
			if( mpos >= DETECT_SIZE ) {
				mpos -= DETECT_SIZE;
			}
			vpos++;// java vpos += 1;
			if( vpos >= DETECT_SIZE ) {
				vpos -= DETECT_SIZE;
			}
		}

		/* The following calculations attempt to minimize a "badness function"
		  for the transition. When switching from speech to music, the badness
		  of switching at frame k is
		  b_k = S*v_k + \sum_{i=0}^{k-1} v_i*(p_i - T)
		  where
		  v_i is the activity probability (VAD) at frame i,
		  p_i is the music probability at frame i
		  T is the probability threshold for switching
		  S is the penalty for switching during active audio rather than silence
		  the current frame has index i=0

		  Rather than apply badness to directly decide when to switch, what we compute
		  instead is the threshold for which the optimal switching point is now. When
		  considering whether to switch now (frame 0) or at frame k, we have:
		  S*v_0 = S*v_k + \sum_{i=0}^{k-1} v_i*(p_i - T)
		  which gives us:
		  T = ( \sum_{i=0}^{k-1} v_i*p_i + S*(v_k-v_0) ) / ( \sum_{i=0}^{k-1} v_i )
		  We take the min threshold across all positive values of k (up to the maximum
		  amount of lookahead we have) to give us the threshold for which the current
		  frame is the optimal switch point.

		  The last step is that we need to consider whether we want to switch at all.
		  For that we use the average of the music probability over the entire window.
		  If the threshold is higher than that average we're not going to
		  switch, so we compute a min with the average as well. The result of all these
		  min operations is music_prob_min, which gives the threshold for switching to music
		  if we're currently encoding for speech.

		  We do the exact opposite to compute music_prob_max which is used for switching
		  from music to speech.
		*/
		float prob_min = 1.f;
		float prob_max = 0.f;
		final float vad_prob = this_info[vpos].activity_probability;
		float prob_count = (.1f >= vad_prob ? 0.1f : vad_prob);
		float prob_avg = prob_count * this_info[mpos].music_prob;// MAX16(.1f, vad_prob) * this.info[mpos].music_prob;// FIXME why not prob_count?
		while( true )
		{
			mpos++;
			if( mpos == DETECT_SIZE ) {
				mpos = 0;
			}
			if( mpos == this.write_pos ) {
				break;
			}
			vpos++;
			if( vpos == DETECT_SIZE ) {
				vpos = 0;
			}
			if( vpos == this.write_pos ) {
				break;
			}
			float pos_vad = this_info[vpos].activity_probability;
			float v = (prob_avg - TRANSITION_PENALTY * (vad_prob - pos_vad)) / prob_count;// java
			if( prob_min > v ) {
				prob_min = v;
			}
			v = (prob_avg + TRANSITION_PENALTY * (vad_prob - pos_vad)) / prob_count;// java
			if( prob_max < v ) {
				prob_max = v;
			}
			if( pos_vad < 0.1f ) {// java
				pos_vad = 0.1f;
			}
			prob_count += pos_vad;
			prob_avg += pos_vad * this_info[mpos].music_prob;
		}
		float v = prob_avg / prob_count;// java
		info_out.music_prob = v;
		if( prob_min > v ) {
			prob_min = v;
		}
		if( prob_max < v ) {
			prob_max = v;
		}
		if( prob_min < 0.f ) {
			prob_min = 0.f;
		}
		if( prob_max > 1.f ) {
			prob_min = 1.f;
		}

		/* If we don't have enough look-ahead, do our best to make a decent decision. */
		if( curr_lookahead < 10 )
		{
			float pmin = prob_min;
			float pmax = prob_max;
			pos = pos0;
			/* Look for min/max in the past. */
			for( int i = 0, ie = (this.count - 1 < 15) ? this.count - 1 : 15; i < ie; i++ )
			{
				pos--;
				if( pos < 0 ) {
					pos = DETECT_SIZE - 1;
				}
				v = this_info[pos].music_prob;// java
				if( pmin > v ) {
					pmin = v;
				}
				if( pmax < v ) {
					pmax = v;
				}
			}
			/* Bias against switching on active audio. */
			v = .1f * vad_prob;// java
			pmin -= v;
			if( pmin < 0.f ) {
				pmin = 0.f;
			}
			pmax += v;
			if( pmin > 1.f ) {
				pmin = 1.f;
			}
			prob_min += (1.f - .1f * curr_lookahead) * (pmin - prob_min);
			prob_max += (1.f - .1f * curr_lookahead) * (pmax - prob_max);
		}
		info_out.music_prob_min = prob_min;
		info_out.music_prob_max = prob_max;

		/* printf("%f %f %f %f %f\n", prob_min, prob_max, prob_avg/prob_count, vad_prob, info_out->music_prob); */
		this.read_subframe += len / (this.Fs / 400);
		while( this.read_subframe >= 8 )
		{
			this.read_subframe -= 8;
			this.read_pos++;
		}
		if( this.read_pos >= DETECT_SIZE ) {
			this.read_pos -= DETECT_SIZE;
		}
	}

	private static final float std_feature_bias[/* 9 */] = {
			5.684947f, 3.475288f, 1.770634f, 1.599784f, 3.773215f,
			2.163313f, 1.260756f, 1.116868f, 1.918795f
	};

	private static final float LEAKAGE_OFFSET = 2.5f;
	private static final float LEAKAGE_SLOPE = 2.f;

// #ifdef FIXED_POINT
/* For fixed-point, the input is +/-2^15 shifted up by SIG_SHIFT, so we need to
   compensate for that in the energy. */
// #define SCALE_COMPENS (1.f/((opus_int32)1<<(15+SIG_SHIFT)))
// #define SCALE_ENER(e) ((SCALE_COMPENS*SCALE_COMPENS)*(e))
// #else
// #define SCALE_ENER(e) (e)
// #endif

	// start mathops.h
	/* CELT doesn't need it for fixed-point, by analysis.c does. */
// #if !defined(FIXED_POINT) || defined(ANALYSIS_C)
private static final float cA = 0.43157974f;
private static final float cB = 0.67848403f;
private static final float cC = 0.08595542f;
private static final float cE = ((float)Math.PI / 2.f);
/*	private static final float fast_atan2f(final float y, final float x) {// java: extracted in place
		final float x2 = x * x;
		final float y2 = y * y;
		// For very small values, we don't care about the answer, so
		//  we can just return 0.
		if( x2 + y2 < 1e-18f )
		{
			return 0;
		}
		if( x2 < y2 ) {
			final float den = (y2 + cB * x2) * (y2 + cC * x2);
			return -x * y * (y2 + cA * x2) / den + (y < 0 ? -cE : cE);
		}// else {
			final float den = (x2 + cB * y2) * (x2 + cC * y2);
			return x * y *(x2 + cA * y2) / den + (y < 0 ? -cE : cE) - (x * y < 0 ? -cE : cE);
		// }
	}
/* #undef cA
#undef cB
#undef cC
#undef cD
#endif */
	// end mathops.h
	private final void tonality_analysis(final JCELTMode celt_mode,
			final Object x, final int xoffset,// java
			int len, int offset, final int c1, final int c2, final int C, final int lsb_depth,
			final Idownmix/*downmix_func*/ downmix )
	{
		final int N = 480, N2 = 240;
		final float[] A = this.angle;
		final float[] dA = this.d_angle;
		final float[] d2A = this.d2_angle;
		final float band_tonality[] = new float[NB_TBANDS];
		final float logE1[] = new float[NB_TBANDS];// java info renamed to avoid hiding a field
		final float BFCC[] = new float[8];
		final float features[] = new float[25];
		/*float tw_sum=0;*/
		final float pi4 = (float)(Math.PI * Math.PI * Math.PI * Math.PI);
		float slope = 0;
		final float frame_probs[] = new float[2];
		final float tonality2[] = new float[240];
		final float midE[] = new float[8];
		final float band_log2[] = new float[NB_TBANDS + 1];
		final float leakage_from[] = new float[NB_TBANDS + 1];
		final float leakage_to[] = new float[NB_TBANDS + 1];
		// SAVE_STACK;

		int i = 1 + this.count;// java
		final float alpha = 1.f / (10 <= i ? 10 : i);
		final float alphaE = 1.f / (25 <= i ? 25 : i);
		/* Noise floor related decay for bandwidth detection: -2.2 dB/second */
		float alphaE2 = 1.f / (100 <= i ? 100 : i);
		if( this.count <= 1 ) {
			alphaE2 = 1f;
		}

		if( this.Fs == 48000 )
		{
			/* len and offset are now at 24 kHz. */
			len >>>= 1;
			offset >>>= 1;
		} else if( this.Fs == 16000 ) {
			len = (3 * len) >>> 1;
			offset = (3 * offset) >>> 1;
		}

		final Jkiss_fft_state kfft = celt_mode.mdct.kfft[0];
		if( this.count == 0 ) {
			this.mem_fill = 240;
		}
		i = ANALYSIS_BUF_SIZE - this.mem_fill;// java
		this.hp_ener_accum += (float)downmix_and_resample( downmix, x, xoffset,
					this.inmem, this.mem_fill, this.downmix_state,
					(len <= i ? len : i), offset, c1, c2, C, this.Fs );
		if( this.mem_fill + len < ANALYSIS_BUF_SIZE )
		{
			this.mem_fill += len;
			/* Don't have enough to update the analysis */
			// RESTORE_STACK;
			return;
		}
		final float hp_ener = this.hp_ener_accum;
		final JAnalysisInfo ainfo = this.info[ this.write_pos++ ];// java info renamed to avoid hiding a field
		if( this.write_pos >= DETECT_SIZE ) {
			this.write_pos -= DETECT_SIZE;
		}

		final Jkiss_fft_cpx in[] = new Jkiss_fft_cpx[480];// objects must be created
		final Jkiss_fft_cpx out[] = new Jkiss_fft_cpx[480];// objects must be created
		int b = 0;// java added to create objects
		do {
			in[b] = new Jkiss_fft_cpx();
			out[b] = new Jkiss_fft_cpx();
		} while( ++b < 480 );
		final float[] tonality = new float[ 240 ];
		final float[] noisiness = new float[ 240 ];
		for( i = 0, b = N - 1; i < N2; i++, b-- )
		{
			final float w = analysis_window[i];
			in[i].r = (w * this.inmem[i]);
			in[i].i = (w * this.inmem[N2 + i]);
			in[b].r = (w * this.inmem[b]);
			in[b].i = (w * this.inmem[b + N2]);
		}
		System.arraycopy( this.inmem, ANALYSIS_BUF_SIZE - 240, this.inmem, 0, 240 );
		final int remaining = len - (ANALYSIS_BUF_SIZE - this.mem_fill);
		this.hp_ener_accum = (float)downmix_and_resample( downmix, x, xoffset,
					this.inmem, 240, this.downmix_state, remaining,
					offset + ANALYSIS_BUF_SIZE - this.mem_fill, c1, c2, C, this.Fs );
		this.mem_fill = 240 + remaining;
		kfft.opus_fft( in, out );// , this.arch );
// #ifndef FIXED_POINT
		/* If there's any NaN on the input, the entire output will be NaN, so we only need to check one value. */
		if( Float.isNaN( out[0].r ) )
		{
			ainfo.valid = false;
			// RESTORE_STACK;
			return;
		}
// #endif

		for( i = 1, b = N - 1; i < N2; i++, b-- )
		{
			final Jkiss_fft_cpx out_i = out[i];// java
			final Jkiss_fft_cpx out_b = out[b];// java
			final float X1r = out_i.r + out_b.r;
			final float X1i = out_i.i - out_b.i;
			final float X2r = out_i.i + out_b.i;
			final float X2i = out_b.r - out_i.r;

			// angle1 = (float)(.5f / Math.PI) * fast_atan2f( X1i, X1r );
			// fast_atan2f( X1i, X1r )
			float angle1 = X1r * X1r;
			float d_angle1 = X1i * X1i;
			if( angle1 + d_angle1 < 1e-18f ) {
				angle1 = 0;
			}
			if( angle1 < d_angle1 ) {
				final float den = (d_angle1 + cB * angle1) * (d_angle1 + cC * angle1);
				angle1 = -X1r * X1i * (d_angle1 + cA * angle1) / den + (X1i < 0 ? -cE : cE);
			} else {
				final float den = (angle1 + cB * d_angle1) * (angle1 + cC * d_angle1);
				angle1 = X1r * X1i *(angle1 + cA * d_angle1) / den + (X1i < 0 ? -cE : cE) - (X1r * X1i < 0 ? -cE : cE);
			}
			angle1 = (float)(.5f / Math.PI) * angle1;
			d_angle1 = angle1 - A[i];
			final float d2_angle1 = d_angle1 - dA[i];

			// final float angle2 = (float)(.5f / Math.PI) * fast_atan2f( X2i, X2r );
			// fast_atan2f( X2i, X2r )
			float angle2 = X2r * X2r;
			float d_angle2 = X2i * X2i;
			// For very small values, we don't care about the answer, so
			//  we can just return 0.
			if( angle2 + d_angle2 < 1e-18f ) {
				angle2 = 0;
			}
			if( angle2 < d_angle2 ) {
				final float den = (d_angle2 + cB * angle2) * (d_angle2 + cC * angle2);
				angle2 = -X2r * X2i * (d_angle2 + cA * angle2) / den + (X2i < 0 ? -cE : cE);
			} else {
				final float den = (angle2 + cB * d_angle2) * (angle2 + cC * d_angle2);
				angle2 = X2r * X2i *(angle2 + cA * d_angle2) / den + (X2i < 0 ? -cE : cE) - (X2r * X2i < 0 ? -cE : cE);
			}
			angle2 = (float)(.5f / Math.PI) * angle2;
			d_angle2 = angle2 - angle1;
			final float d2_angle2 = d_angle2 - d_angle1;

			float mod1 = d2_angle1 - (float)((int)(Math.floor((double)(.5f + d2_angle1))));
			noisiness[i] = (mod1 >= 0 ? mod1 : -mod1);
			mod1 *= mod1;
			mod1 *= mod1;

			float mod2 = d2_angle2 - (float)((int)(Math.floor((double)(.5f + d2_angle2))));
			noisiness[i] += (mod2 >= 0 ? mod2 : -mod2);
			mod2 *= mod2;
			mod2 *= mod2;

			final float avg_mod = .25f * (d2A[i] + mod1 + 2 * mod2);
			/* This introduces an extra delay of 2 frames in the detection. */
			tonality[i] = 1.f / (1.f + 40.f * 16.f * pi4 * avg_mod) - .015f;
			/* No delay on this detection, but it's less reliable. */
			tonality2[i] = 1.f / (1.f + 40.f * 16.f * pi4 * mod2) - .015f;

			A[i] = angle2;
			dA[i] = d_angle2;
			d2A[i] = mod2;
		}
		for( i = 2; i < N2 - 1; i++ )
		{
			float v = tonality2[i - 1];// java
			float tt = tonality2[i + 1];// java
			tt = v >= tt ? v : tt;// java
			v = tonality2[i];// java
			tt = (v < tt ? v : tt);// java
			tt -= 0.1f;// java
			v = tonality[i];// java
			tonality[i] = .9f * (v > tt ? v : tt);
		}
		float frame_tonality = 0;
		float max_frame_tonality = 0;
		/*tw_sum = 0;*/
		ainfo.activity = 0;
		float frame_noisiness = 0;
		float frame_stationarity = 0;
		if( this.count == 0 )
		{
			for( b = 0; b < NB_TBANDS; b++ )
			{
				this.lowE[b] = 1e10f;
				this.highE[b] = -1e10f;
			}
		}
		float relativeE = 0;
		float frame_loudness = 0;
		/* The energy of the very first band is special because of DC. */
		{
			float E1 = 0;// java E renamed to avoid hiding a field
			final float X1r = 2 * out[0].r;
			final float X2r = 2 * out[0].i;
			E1 = X1r * X1r + X2r * X2r;
			for( i = 1; i < 4; i++ )
			{
				final Jkiss_fft_cpx out_i = out[i];
				final Jkiss_fft_cpx out_ni = out[N - i];
				final float binE = out_i.r * out_i.r + out_ni.r * out_ni.r
						+ out_i.i * out_i.i + out_ni.i * out_ni.i;
				E1 += binE;
			}
			// E = SCALE_ENER(E);
			band_log2[0] = .5f * 1.442695f * (float)Math.log( (double)(E1 + 1e-10f) );
		}
		for( b = 0; b < NB_TBANDS; b++ )
		{
			float E1 = 0, tE = 0, nE = 0;// java E renamed to avoid hiding a field
			i = tbands[b];
			for( final int ie = tbands[b + 1]; i < ie; i++ )
			{
				final Jkiss_fft_cpx out_i = out[i];
				final Jkiss_fft_cpx out_ni = out[N - i];
				final float binE = out_i.r * out_i.r + out_ni.r * out_ni.r
						+ out_i.i * out_i.i + out_ni.i * out_ni.i;
				// binE = SCALE_ENER(binE);
				E1 += binE;
				final float v = tonality[i];// java
				tE += binE * (0 >= v ? 0 : v);
				nE += binE * 2.f * (.5f - noisiness[i]);
			}
// ifndef FIXED_POINT
			/* Check for extreme band energies that could cause NaNs later. */
			if( !(E1 < 1e9f) || Float.isNaN( E1 ) )
			{
				ainfo.valid = false;
				// RESTORE_STACK;
				return;
			}
// #endif

			this.E[this.E_count][b] = E1;
			frame_noisiness += nE / (1e-15f + E1);

			{// java
			double v = (double)(E1 + 1e-10f);
			frame_loudness += (float)Math.sqrt( v );
			v = (float)Math.log( v );
			logE1[b] = (float)v;
			band_log2[b + 1] = .5f * 1.442695f * (float)v;
			}
			this.logE[this.E_count][b] = logE1[b];
			if( this.count == 0 ) {
				this.highE[b] = this.lowE[b] = logE1[b];
			}
			if( this.highE[b] > this.lowE[b] + 7.5f )
			{
				if( this.highE[b] - logE1[b] > logE1[b] - this.lowE[b] ) {
					this.highE[b] -= .01f;
				} else {
					this.lowE[b] += .01f;
				}
			}
			if( logE1[b] > this.highE[b] )
			{
				this.highE[b] = logE1[b];
				final float v1 = this.highE[b] - 15;
				final float v2 = this.lowE[b];
				this.lowE[b] = ( v1 >= v2 ? v1 : v2 );
			} else if( logE1[b] < this.lowE[b] )
			{
				this.lowE[b] = logE1[b];
				final float v1 = this.lowE[b] + 15;
				final float v2 = this.highE[b];
				this.highE[b] = ( v1 <= v2 ? v1 : v2 );
			}
			relativeE += (logE1[b] - this.lowE[b]) / (1e-15f + (this.highE[b] - this.lowE[b]));

			float L1, L2;
			L1 = L2 = 0;
			for( i = 0; i < NB_FRAMES; i++ )
			{
				L1 += (float)Math.sqrt( this.E[i][b] );
				L2 += this.E[i][b];
			}

			float stationarity = L1 / (float)Math.sqrt( 1e-15 + NB_FRAMES * L2 );// java
			stationarity = ( 0.99f <= stationarity ? 0.99f : stationarity );
			stationarity *= stationarity;
			stationarity *= stationarity;
			frame_stationarity += stationarity;
			/*band_tonality[b] = tE/(1e-15+E)*/;
			L1 = tE / (1e-15f + E1);// java
			L2 = stationarity * this.prev_band_tonality[b];// java
			L2 = ( L1 >= L2 ? L1 : L2 );// java
			band_tonality[b] = L2;
/* #if 0
			if( b >= NB_TONAL_SKIP_BANDS )
			{
				frame_tonality += tweight[b] * band_tonality[b];
				tw_sum += tweight[b];
			}
#else */
			frame_tonality += L2;// java band_tonality[b];
			if( b >= NB_TBANDS - NB_TONAL_SKIP_BANDS ) {
				frame_tonality -= band_tonality[b - NB_TBANDS + NB_TONAL_SKIP_BANDS];
			}
// #endif
			L1 = (1.f + .03f * (b - NB_TBANDS)) * frame_tonality;// java
			max_frame_tonality = (max_frame_tonality >= L1 ? max_frame_tonality : L1);
			slope += L2 * (b - 8);// java band_tonality[b] * (b - 8);
			/*printf("%f %f ", band_tonality[b], stationarity);*/
			this.prev_band_tonality[b] = L2;// java band_tonality[b];
		}

		leakage_from[0] = band_log2[0];
		leakage_to[0] = band_log2[0] - LEAKAGE_OFFSET;
		for( b = 1; b < NB_TBANDS + 1; b++ )
		{
			final float leak_slope = LEAKAGE_SLOPE * (tbands[b] - tbands[b - 1]) / 4;
			float b2 = band_log2[b];// java
			float v = leakage_from[b - 1] + leak_slope;// java
			leakage_from[b] = (v <= b2 ? v : b2);
			v = leakage_to[b - 1] - leak_slope;// java
			b2 -= LEAKAGE_OFFSET;// java
			leakage_to[b] = (v >= b2 ? v : b2);
		}
		for( b = NB_TBANDS - 2; b >= 0; b-- )
		{
			final float leak_slope = LEAKAGE_SLOPE * (tbands[b + 1] - tbands[b]) / 4;
			float v1 = leakage_from[b + 1] + leak_slope;// java
			float v2 = leakage_from[b];// java
			leakage_from[b] = (v1 <= v2 ? v1 : v2);
			v1 = leakage_to[b + 1] - leak_slope;// java
			v2 = leakage_to[b];// java
			leakage_to[b] = (v1 >= v2 ? v1 : v2);
		}
		// celt_assert(NB_TBANDS+1 <= LEAK_BANDS);
		for( b = 0; b < NB_TBANDS + 1; b++ )
		{
			/* leak_boost[] is made up of two terms. The first, based on leakage_to[],
  			   represents the boost needed to overcome the amount of analysis leakage
  			   cause in a weaker band b by louder neighbouring bands.
  			   The second, based on leakage_from[], applies to a loud band b for
  			   which the quantization noise causes synthesis leakage to the weaker
  			   neighbouring bands. */
			float b2 = band_log2[b];// java
			float boost = leakage_to[b] - b2;// java
			boost = (0 >= boost ? 0 : boost);// java
			b2 -= (leakage_from[b] + LEAKAGE_OFFSET);// java
			boost += (0 >= b2 ? 0 : b2);
			i = (int)Math.floor(.5 + 64.f * boost);// java
			ainfo.leak_boost[b] = (char)(255 <= i ? 255 : i);
		}
		for( b = NB_TBANDS + 1; b < Jcelt.LEAK_BANDS; b++ ) {
			ainfo.leak_boost[b] = 0;
		}

		float spec_variability = 0;
		for( i = 0; i < NB_FRAMES; i++ )
		{
			float mindist = 1e15f;
			for( int j = 0; j < NB_FRAMES; j++ )
			{
				float dist = 0;
				for( int k = 0; k < NB_TBANDS; k++ )
				{
					final float tmp = this.logE[i][k] - this.logE[j][k];
					dist += tmp * tmp;
				}
				if( j != i ) {
					mindist = (mindist <= dist ? mindist : dist);
				}
			}
			spec_variability += mindist;
		}
		spec_variability = (float)Math.sqrt( spec_variability / NB_FRAMES / NB_TBANDS );
		float bandwidth_mask = 0;
		int bandwidth = 0;
		float maxE = 0;
		i = lsb_depth - 8;// java
		float noise_floor = 5.7e-4f / (1 << (0 >= i ? 0 : i));
		noise_floor *= noise_floor;
		float below_max_pitch = 0;
		float above_max_pitch = 0;
		final boolean is_masked[] = new boolean[ NB_TBANDS + 1 ];
		for( b = 0; b < NB_TBANDS; b++ )
		{
			float E1 = 0;// java E renamed to avoid hiding a field
			/* Keep a margin of 300 Hz for aliasing */
			final int band_start = tbands[b];
			final int band_end = tbands[b + 1];
			for( i = band_start; i < band_end; i++ )
			{
				final float binE = out[i].r * out[i].r + out[N - i].r * out[N - i].r
						+ out[i].i * out[i].i + out[N - i].i * out[N - i].i;
				E1 += binE;
			}
			// E1 = SCALE_ENER( E1 );
			maxE = (maxE >= E1 ? maxE : E1);
			if( band_start < 64 )
			{
				below_max_pitch += E1;
			} else {
				above_max_pitch += E1;
			}
			float v = (1 - alphaE2) * this.meanE[b];// java
			v = ( v >= E1 ? v : E1 );
			this.meanE[b] = v;
			final float Em = (E1 >= v ? E1 : v);
			/* Consider the band "active" only if all these conditions are met:
			   1) less than 90 dB below the peak band (maximal masking possible considering
			      both the ATH and the loudness-dependent slope of the spreading function)
			   2) above the PCM quantization noise floor
			   We use b+1 because the first CELT band isn't included in tbands[]
			 */
			if( E1 * 1e9f > maxE && (Em > 3 * noise_floor * (band_end - band_start) || E1 > noise_floor * (band_end - band_start)) ) {
				bandwidth = b + 1;
			}
			/* Check if the band is masked (see below). */
			is_masked[b] = E1 < (this.prev_bandwidth >= b + 1 ? .01f : .05f) * bandwidth_mask;
			/* Use a simple follower with 13 dB/Bark slope for spreading function. */
			bandwidth_mask *= .05f;// java MAX32(.05f * bandwidth_mask, E1);
			if( bandwidth_mask < E1 ) {
				bandwidth_mask = E1;
			}
		}
		/* Special case for the last two bands, for which we don't have spectrum but only
		   the energy above 12 kHz. The difficulty here is that the high-pass we use
		   leaks some LF energy, so we need to increase the threshold without accidentally cutting
		   off the band. */
		if( this.Fs == 48000 ) {
			final float E1 = hp_ener * (1.f / (60 * 60));// java E renamed to avoid hiding a field
			final float noise_ratio = this.prev_bandwidth == 20 ? 10.f : 30.f;

// #ifdef FIXED_POINT
			/* silk_resampler_down2_hp() shifted right by an extra 8 bits. */
//			E1 *= 256.f * (1.f / Q15ONE) * (1.f / Q15ONE);
// #endif
			above_max_pitch += E1;
			float Em = (1 - alphaE2) * this.meanE[b];// java this.meanE[b] = MAX32((1 - alphaE2) * this.meanE[b], E1);
			if( Em < E1 ) {
				Em = E1;
			}
			this.meanE[b] = Em;// java Em = MAX32(E, tonal->meanE[b]);
			if( Em < E1 ) {
				Em = E1;
			}
			if( Em > 3 * noise_ratio * noise_floor * 160 || E1 > noise_ratio * noise_floor * 160 ) {
				bandwidth = 20;
			}
			/* Check if the band is masked (see below). */
			is_masked[b] = E1 < (this.prev_bandwidth == 20  ? .01f : .05f) * bandwidth_mask;
		}
		if( above_max_pitch > below_max_pitch ) {
			ainfo.max_pitch_ratio = below_max_pitch / above_max_pitch;
		} else {
			ainfo.max_pitch_ratio = 1f;
		}
		/* In some cases, resampling aliasing can create a small amount of energy in the first band
		   being cut. So if the last band is masked, we don't include it.  */
		if( bandwidth == 20 && is_masked[NB_TBANDS] ) {
			bandwidth-=2;
		} else if( bandwidth > 0 && bandwidth <= NB_TBANDS && is_masked[bandwidth - 1] ) {
			bandwidth--;
		}
		if( this.count <= 2 ) {
			bandwidth = 20;
		}
		frame_loudness = 20 * (float)Math.log10( (double)frame_loudness );
		float v = this.Etracker - .003f;// java
		this.Etracker = (v >= frame_loudness ? v : frame_loudness);
		this.lowECount *= (1 - alphaE);
		if( frame_loudness < this.Etracker - 30 ) {
			this.lowECount += alphaE;
		}

		for( i = 0; i < 8; i++ )
		{
			float sum = 0;
			b = 0;
			for( int i16 = i << 4; b < 16; ) {
				sum += dct_table[i16++] * logE1[b++];
			}
			BFCC[i] = sum;
		}
		for( i = 0; i < 8; i++ )
		{
			float sum = 0;
			b = 0;
			for( int i16 = i << 4; b < 16; b++ ) {
				sum += dct_table[i16++] * .5f * (this.highE[b] + this.lowE[b]);
			}
			midE[i] = sum;
		}

		frame_stationarity /= NB_TBANDS;
		relativeE /= NB_TBANDS;
		if( this.count < 10 ) {
			relativeE = .5f;
		}
		frame_noisiness /= NB_TBANDS;
// #if 1
		ainfo.activity = frame_noisiness + (1 - frame_noisiness) * relativeE;
// #else
		ainfo.activity = .5f * (1 + frame_noisiness - frame_stationarity);
// #endif
		frame_tonality = (max_frame_tonality / (NB_TBANDS - NB_TONAL_SKIP_BANDS));
		v = this.prev_tonality * .8f;// java
		frame_tonality = (frame_tonality >= v ? frame_tonality : v);
		this.prev_tonality = frame_tonality;

		slope /= 8 * 8;
		ainfo.tonality_slope = slope;

		this.E_count = (this.E_count + 1) % NB_FRAMES;
		i = this.count + 1;// java
		this.count = (i <= ANALYSIS_COUNT_MAX ? i : ANALYSIS_COUNT_MAX);
		ainfo.tonality = frame_tonality;

		for( i = 0; i < 4; i++ ) {
			features[i] = -0.12299f * (BFCC[i] + this.mem[i + 24]) + 0.49195f *
				(this.mem[i] + this.mem[i + 16]) + 0.69693f * this.mem[i + 8] - 1.4349f * this.cmean[i];
		}

		for( i = 0; i < 4; i++ ) {
			this.cmean[i] = (1 - alpha) * this.cmean[i] + alpha * BFCC[i];
		}

		for( i = 0; i < 4; i++ ) {
			features[4 + i] = 0.63246f * (BFCC[i] - this.mem[i + 24]) + 0.31623f * (this.mem[i] - this.mem[i + 16]);
		}
		for( i = 0; i < 3; i++ ) {
			features[8 + i] = 0.53452f * (BFCC[i] + this.mem[i + 24]) - 0.26726f*(this.mem[i] + this.mem[i + 16]) - 0.53452f * this.mem[i + 8];
		}

		if( this.count > 5 )
		{
			for( i = 0; i < 9; i++ ) {
				v = features[i];// java
				this.std[i] = (1 - alpha) * this.std[i] + alpha * v * v;
			}
		}
		for( i = 0; i < 4; i++ ) {
			features[i] = BFCC[i] - midE[i];
		}

		for( i = 0; i < 8; i++ )
		{
			this.mem[i + 24] = this.mem[i + 16];
			this.mem[i + 16] = this.mem[i + 8];
			this.mem[i + 8] = this.mem[i];
			this.mem[i] = BFCC[i];
		}
		for( i = 0; i < 9; i++ ) {
			features[11 + i] = (float)Math.sqrt( (double)this.std[i] ) - std_feature_bias[i];
		}
		features[18] = spec_variability - 0.78f;
		features[20] = ainfo.tonality - 0.154723f;
		features[21] = ainfo.activity - 0.724643f;
		features[22] = frame_stationarity - 0.743717f;
		features[23] = ainfo.tonality_slope + 0.069216f;
		features[24] = this.lowECount - 0.067930f;

		final float layer_out[] = new float[Jmlp.MAX_NEURONS];
		layer0.compute_dense( layer_out, features );
		layer1.compute_gru( this.rnn_state, layer_out );
		layer2.compute_dense( frame_probs, this.rnn_state );

		/* Probability of speech or music vs noise */
		ainfo.activity_probability = frame_probs[1];
		ainfo.music_prob = frame_probs[0];

	    /*printf("%f %f %f\n", frame_probs[0], frame_probs[1], info->music_prob);*/
/* #ifdef MLP_TRAINING
		for( i = 0; i < 25; i++ ) {
			printf("%f ", features[i]);
		}
		printf("\n");
#endif */

		ainfo.bandwidth = bandwidth;
		this.prev_bandwidth = bandwidth;
		/*printf("%d %d\n", info->bandwidth, info->opus_bandwidth);*/
		ainfo.noisiness = frame_noisiness;
		ainfo.valid = true;
		// RESTORE_STACK;
	}

	final void run_analysis(final JCELTMode celt_mode,
			final Object analysis_pcm, final int pcmoffset,// java
			int analysis_frame_size, final int frame_size, final int c1, final int c2, final int C, final int iFs,
			final int lsb_depth, final Idownmix/*downmix_func*/ downmix, final JAnalysisInfo analysis_info)
	{
		analysis_frame_size -= analysis_frame_size & 1;
		if( analysis_pcm != null )
		{
			/* Avoid overflow/wrap-around of the analysis buffer */
			final int f50 = iFs / 50;// java
			int pcm_len = (DETECT_SIZE - 5) * f50;// java
			analysis_frame_size = pcm_len < analysis_frame_size ? pcm_len : analysis_frame_size;

			pcm_len = analysis_frame_size - this.analysis_offset;
			int offset = this.analysis_offset;
			while( pcm_len > 0 ) {
				tonality_analysis( celt_mode, analysis_pcm, pcmoffset, (f50 <= pcm_len ?  f50 : pcm_len), offset, c1, c2, C, lsb_depth, downmix );
				offset += f50;
				pcm_len -= f50;
			}
			this.analysis_offset = analysis_frame_size;

			this.analysis_offset -= frame_size;
		}

		analysis_info.valid = false;
		tonality_get_info( analysis_info, frame_size );
	}
// #endif /* DISABLE_FLOAT_API */
}